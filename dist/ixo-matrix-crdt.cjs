"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const k=require("matrix-js-sdk"),y=require("vscode-lib"),gt=require("yjs");require("another-json");const yt=require("lodash"),wt=require("simple-peer");function ge(t){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(t){for(const s in t)if(s!=="default"){const n=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(e,s,n.get?n:{enumerable:!0,get:()=>t[s]})}}return e.default=t,Object.freeze(e)}const bt=ge(k),p=ge(gt),vt=ge(yt);async function Fe(t,e){const s=t.getUserId();if(!s)throw new Error("User ID not available");e.userId=s,e.timestamp=Date.now(),console.log(`Tagged WebRTC message from user: ${s}`)}async function Ne(t,e,s,n){if(!s.userId)throw new Error("WebRTC message missing user identification");if(s.timestamp){const r=Date.now()-s.timestamp,o=60*1e3;if(r>o){console.warn(`Old WebRTC message ignored (${Math.round(r/1e3)}s old)`);return}}if(!await e.isValidMember(s.userId))throw new Error(`User ${s.userId} is not authorized for this collaboration room`);console.log(`Verified WebRTC message from authorized room member: ${s.userId}`)}class ze extends y.lifecycle.Disposable{constructor(e,s){super(),this.matrixClient=e,this.reader=s,this._register(this.reader.onEvents(n=>n.events.forEach(i=>this.processEvent(i))))}disposed=!1;initialized=!1;initializing=!1;initializeOutdated=!1;members=new Map;powerLevels;hasWriteAccess(e,s="m.room.message"){if(!this.members.has(e))return!1;const n=this.powerLevels;let i=n.events[s];i===void 0&&(i=n.events_default);let r=n.users[e];if(r===void 0&&(r=n.users_default),typeof r!="number"||typeof i!="number")throw new Error("unexpected");return r>=i}async isValidMember(e){return this.members.has(e)}processEvent=e=>{if(!(e.type!=="m.room.power_levels"&&e.type!=="m.room.member")){if(this.initializing){this.initializeOutdated=!0;return}if(this.initialized){if(e.type==="m.room.power_levels"){this.powerLevels=e.content;return}if(e.type==="m.room.member"){if(e.content.membership==="join"||e.content.membership==="invite"){const s={displayname:e.content.displayname,user_id:e.state_key};this.members.set(e.state_key,s)}else this.members.delete(e.state_key);return}throw new Error("unexpected")}}};async initialize(){if(this.initializing||this.initialized)throw new Error("already initializing / initialized");if(!this.reader.isStarted)throw new Error("MatrixReader must have started before initializing MatrixMemberReader");this.initializing=!0;const[e,s]=await Promise.all([this.matrixClient.getStateEvent(this.reader.roomId,"m.room.power_levels",void 0),this.matrixClient.members(this.reader.roomId,void 0,["knock","leave","ban"])]);if(this.initializeOutdated)return this.initializing=!1,this.initializeOutdated=!1,this.initialize();this.powerLevels=e,s.chunk.filter(n=>n.type==="m.room.member"&&(n.content.membership==="join"||n.content.membership==="invite")).forEach(n=>{this.members.set(n.state_key,{displayname:n.content.displayname,user_id:n.state_key})}),this.initializing=!1,this.initialized=!0}dispose(){this.disposed=!0,super.dispose()}}const St=30*1e3,Ct=30*1e3,It={snapshotInterval:30};class Et extends y.lifecycle.Disposable{constructor(e,s,n,i={}){super(),this.matrixClient=e,this.roomId=s,this.translator=n,this.opts={...It,...i},this.matrixClient.on(k.RoomEvent.Timeline,this.matrixRoomListener)}latestToken;disposed=!1;polling=!1;pendingPollRequest;pollRetryTimeout;messagesSinceSnapshot=0;_onEvents=this._register(new y.event.Emitter);onEvents=this._onEvents.event;opts;matrixRoomListener=(e,s,n)=>{throw console.error("not expected; Room.timeline on MatrixClient"),new Error("unexpected, we don't use /sync calls for MatrixReader, startClient should not be used on the Matrix client")};processIncomingEventsForSnapshot(e){let s=!1;for(let n of e)if(this.translator.isUpdateEvent(n)){if(n.room_id!==this.roomId)throw new Error("event received with invalid roomid");this.messagesSinceSnapshot++,this.messagesSinceSnapshot%this.opts.snapshotInterval===0&&n.user_id===this.matrixClient.credentials.userId&&(s=!0)}else this.translator.isSnapshotEvent(n)&&(this.messagesSinceSnapshot=0,s=!1);return s}async decryptRawEventsIfNecessary(e){return await Promise.all(e.map(async n=>{if(n.type==="m.room.encrypted"){const i=new k.MatrixEvent(n);return await this.matrixClient.decryptEventIfNeeded(i),i.getEffectiveEvent()}else return n}))}async peekPoll(){if(!this.latestToken)throw new Error("polling but no pagination token");if(!this.disposed)try{this.pendingPollRequest=this.matrixClient.http.authedRequest(k.Method.Get,"/events",{room_id:this.roomId,timeout:St.toString(),from:this.latestToken});const e=await this.pendingPollRequest;if(this.pendingPollRequest=void 0,this.disposed)return;const s=await this.decryptRawEventsIfNecessary(e.chunk),n=this.processIncomingEventsForSnapshot(s);s.length&&this._onEvents.fire({events:s,shouldSendSnapshot:n}),this.latestToken=e.end,this.peekPoll()}catch(e){console.error("peek error",e),this.disposed||(this.pollRetryTimeout=setTimeout(()=>this.peekPoll(),Ct))}}async getInitialDocumentUpdateEvents(e){let s=[],n="",i=!0,r;for(;i;){const o=await this.matrixClient.createMessagesRequest(this.roomId,n,30,k.Direction.Backward),a=await this.decryptRawEventsIfNecessary(o.chunk);for(let c of a)if(e)c.type===e&&s.push(c);else if(this.translator.isSnapshotEvent(c))s.push(c),r=c.content.last_event_id;else if(this.translator.isUpdateEvent(c)){if(r&&r===c.event_id)return this.latestToken||(this.latestToken=o.start),s.reverse();this.messagesSinceSnapshot++,s.push(c)}n=o.end||"",this.latestToken||(this.latestToken=o.start),i=!!(o.start!==o.end&&o.end)}return s.reverse()}startPolling(){if(this.polling)throw new Error("already polling");this.polling=!0,this.peekPoll()}get isStarted(){return this.polling}dispose(){this.disposed=!0,super.dispose(),this.pollRetryTimeout&&clearTimeout(this.pollRetryTimeout),this.pendingPollRequest,this.matrixClient.off(k.RoomEvent.Timeline,this.matrixRoomListener)}}const je=64,R=128,ce=63,_=127,Ut=2147483647,D=Math.floor,At=Math.abs,_t=Math.log10,Ve=(t,e)=>t<e?t:e,$e=(t,e)=>t>e?t:e,Mt=t=>t!==0?t<0:1/t<0,He=Number.MAX_SAFE_INTEGER,xt=Number.isInteger||(t=>typeof t=="number"&&isFinite(t)&&D(t)===t),ye=()=>new Set,Tt=Array.from,Pt=Array.isArray,kt=String.fromCharCode,Rt=t=>t.toLowerCase(),Dt=/^\s*/g,Lt=t=>t.replace(Dt,""),Bt=/([A-Z])/g,Ae=(t,e)=>Lt(t.replace(Bt,s=>`${e}${Rt(s)}`)),Ot=t=>{const e=unescape(encodeURIComponent(t)),s=e.length,n=new Uint8Array(s);for(let i=0;i<s;i++)n[i]=e.codePointAt(i);return n},j=typeof TextEncoder<"u"?new TextEncoder:null,Wt=t=>j.encode(t),le=j?Wt:Ot;let N=typeof TextDecoder>"u"?null:new TextDecoder("utf-8",{fatal:!0,ignoreBOM:!0});N&&N.decode(new Uint8Array).length===1&&(N=null);const ne=t=>new Error(t);class Ft{constructor(){this.cpos=0,this.cbuf=new Uint8Array(100),this.bufs=[]}}const u=()=>new Ft,Nt=t=>{let e=t.cpos;for(let s=0;s<t.bufs.length;s++)e+=t.bufs[s].length;return e},f=t=>{const e=new Uint8Array(Nt(t));let s=0;for(let n=0;n<t.bufs.length;n++){const i=t.bufs[n];e.set(i,s),s+=i.length}return e.set(new Uint8Array(t.cbuf.buffer,0,t.cpos),s),e},zt=(t,e)=>{const s=t.cbuf.length;s-t.cpos<e&&(t.bufs.push(new Uint8Array(t.cbuf.buffer,0,t.cpos)),t.cbuf=new Uint8Array($e(s,e)*2),t.cpos=0)},d=(t,e)=>{const s=t.cbuf.length;t.cpos===s&&(t.bufs.push(t.cbuf),t.cbuf=new Uint8Array(s*2),t.cpos=0),t.cbuf[t.cpos++]=e},_e=d,l=(t,e)=>{for(;e>_;)d(t,R|_&e),e=D(e/128);d(t,_&e)},jt=(t,e)=>{const s=Mt(e);for(s&&(e=-e),d(t,(e>ce?R:0)|(s?je:0)|ce&e),e=D(e/64);e>0;)d(t,(e>_?R:0)|_&e),e=D(e/128)},he=new Uint8Array(3e4),Vt=he.length/3,$t=(t,e)=>{if(e.length<Vt){const s=j.encodeInto(e,he).written||0;l(t,s);for(let n=0;n<s;n++)d(t,he[n])}else m(t,le(e))},Ht=(t,e)=>{const s=unescape(encodeURIComponent(e)),n=s.length;l(t,n);for(let i=0;i<n;i++)d(t,s.codePointAt(i))},L=j&&j.encodeInto?$t:Ht,qt=(t,e)=>{const s=t.cbuf.length,n=t.cpos,i=Ve(s-n,e.length),r=e.length-i;t.cbuf.set(e.subarray(0,i),n),t.cpos+=i,r>0&&(t.bufs.push(t.cbuf),t.cbuf=new Uint8Array($e(s*2,r)),t.cbuf.set(e.subarray(i)),t.cpos=r)},m=(t,e)=>{l(t,e.byteLength),qt(t,e)},we=(t,e)=>{zt(t,e);const s=new DataView(t.cbuf.buffer,t.cpos,e);return t.cpos+=e,s},Gt=(t,e)=>we(t,4).setFloat32(0,e,!1),Jt=(t,e)=>we(t,8).setFloat64(0,e,!1),Yt=(t,e)=>we(t,8).setBigInt64(0,e,!1),Me=new DataView(new ArrayBuffer(4)),Kt=t=>(Me.setFloat32(0,t),Me.getFloat32(0)===t),Y=(t,e)=>{switch(typeof e){case"string":d(t,119),L(t,e);break;case"number":xt(e)&&At(e)<=Ut?(d(t,125),jt(t,e)):Kt(e)?(d(t,124),Gt(t,e)):(d(t,123),Jt(t,e));break;case"bigint":d(t,122),Yt(t,e);break;case"object":if(e===null)d(t,126);else if(Pt(e)){d(t,117),l(t,e.length);for(let s=0;s<e.length;s++)Y(t,e[s])}else if(e instanceof Uint8Array)d(t,116),m(t,e);else{d(t,118);const s=Object.keys(e);l(t,s.length);for(let n=0;n<s.length;n++){const i=s[n];L(t,i),Y(t,e[i])}}break;case"boolean":d(t,e?120:121);break;default:d(t,127)}},qe=ne("Unexpected end of array"),Ge=ne("Integer out of Range");class Xt{constructor(e){this.arr=e,this.pos=0}}const T=t=>new Xt(t),Qt=(t,e)=>{const s=new Uint8Array(t.arr.buffer,t.pos+t.arr.byteOffset,e);return t.pos+=e,s},C=t=>Qt(t,w(t)),K=t=>t.arr[t.pos++],w=t=>{let e=0,s=1;const n=t.arr.length;for(;t.pos<n;){const i=t.arr[t.pos++];if(e=e+(i&_)*s,s*=128,i<R)return e;if(e>He)throw Ge}throw qe},Zt=t=>{let e=t.arr[t.pos++],s=e&ce,n=64;const i=(e&je)>0?-1:1;if((e&R)===0)return i*s;const r=t.arr.length;for(;t.pos<r;){if(e=t.arr[t.pos++],s=s+(e&_)*n,n*=128,e<R)return i*s;if(s>He)throw Ge}throw qe},es=t=>{let e=w(t);if(e===0)return"";{let s=String.fromCodePoint(K(t));if(--e<100)for(;e--;)s+=String.fromCodePoint(K(t));else for(;e>0;){const n=e<1e4?e:1e4,i=t.arr.subarray(t.pos,t.pos+n);t.pos+=n,s+=String.fromCodePoint.apply(null,i),e-=n}return decodeURIComponent(escape(s))}},ts=t=>N.decode(C(t)),V=N?ts:es,be=(t,e)=>{const s=new DataView(t.arr.buffer,t.arr.byteOffset+t.pos,e);return t.pos+=e,s},ss=t=>be(t,4).getFloat32(0,!1),ns=t=>be(t,8).getFloat64(0,!1),is=t=>be(t,8).getBigInt64(0,!1),rs=[t=>{},t=>null,Zt,ss,ns,is,t=>!1,t=>!0,V,t=>{const e=w(t),s={};for(let n=0;n<e;n++){const i=V(t);s[i]=X(t)}return s},t=>{const e=w(t),s=[];for(let n=0;n<e;n++)s.push(X(t));return s},C],X=t=>rs[127-K(t)](t),ve=0,Je=1,Se=2,os=(t,e)=>{l(t,ve);const s=p.encodeStateVector(e);m(t,s)},as=(t,e,s)=>{l(t,Je),m(t,p.encodeStateAsUpdate(e,s))},cs=(t,e,s)=>as(e,s,C(t)),Ye=(t,e,s)=>{try{p.applyUpdate(e,C(t),s)}catch(n){console.error("Caught error while handling a Yjs update",n)}},Ke=(t,e)=>{l(t,Se),m(t,e)},ls=Ye,Xe=(t,e,s,n)=>{const i=w(t);switch(i){case ve:cs(t,e,s);break;case Je:Ye(t,s,n);break;case Se:ls(t,s,n);break;default:throw new Error("Unknown message type")}return i},M=()=>new Map,$=(t,e,s)=>{let n=t.get(e);return n===void 0&&t.set(e,n=s()),n},hs=(t,e)=>{const s=[];for(const[n,i]of t)s.push(e(i,n));return s},xe=t=>t===void 0?null:t;class ds{constructor(){this.map=new Map}setItem(e,s){this.map.set(e,s)}getItem(e){return this.map.get(e)}}let Qe=new ds,Ce=!0;try{typeof localStorage<"u"&&localStorage&&(Qe=localStorage,Ce=!1)}catch{}const Ze=Qe,us=t=>Ce||addEventListener("storage",t),fs=t=>Ce||removeEventListener("storage",t),ps=Object.keys,Te=t=>ps(t).length,ms=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),Pe=Symbol("Equality"),gs=()=>{},z=(t,e)=>{if(t===e)return!0;if(t==null||e==null||t.constructor!==e.constructor)return!1;if(t[Pe]!=null)return t[Pe](e);switch(t.constructor){case ArrayBuffer:t=new Uint8Array(t),e=new Uint8Array(e);case Uint8Array:{if(t.byteLength!==e.byteLength)return!1;for(let s=0;s<t.length;s++)if(t[s]!==e[s])return!1;break}case Set:{if(t.size!==e.size)return!1;for(const s of t)if(!e.has(s))return!1;break}case Map:{if(t.size!==e.size)return!1;for(const s of t.keys())if(!e.has(s)||!z(t.get(s),e.get(s)))return!1;break}case Object:if(Te(t)!==Te(e))return!1;for(const s in t)if(!ms(t,s)||!z(t[s],e[s]))return!1;break;case Array:if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(!z(t[s],e[s]))return!1;break;default:return!1}return!0},ys=(t,e)=>e.includes(t),B=typeof process<"u"&&process.release&&/node|io\.js/.test(process.release.name)&&Object.prototype.toString.call(typeof process<"u"?process:0)==="[object process]",et=typeof window<"u"&&typeof document<"u"&&!B;let v;const ws=()=>{if(v===void 0)if(B){v=M();const t=process.argv;let e=null;for(let s=0;s<t.length;s++){const n=t[s];n[0]==="-"?(e!==null&&v.set(e,""),e=n):e!==null&&(v.set(e,n),e=null)}e!==null&&v.set(e,"")}else typeof location=="object"?(v=M(),(location.search||"?").slice(1).split("&").forEach(t=>{if(t.length!==0){const[e,s]=t.split("=");v.set(`--${Ae(e,"-")}`,s),v.set(`-${Ae(e,"-")}`,s)}})):v=M();return v},de=t=>ws().has(t),Q=t=>xe(B?process.env[t.toUpperCase().replaceAll("-","_")]:Ze.getItem(t)),tt=t=>de("--"+t)||Q(t)!==null;tt("production");const bs=B&&ys(process.env.FORCE_COLOR,["true","1","2"]),vs=bs||!de("--no-colors")&&!tt("no-color")&&(!B||process.stdout.isTTY)&&(!B||de("--color")||Q("COLORTERM")!==null||(Q("TERM")||"").includes("color"));class Ss{constructor(e,s){this.left=e,this.right=s}}const S=(t,e)=>new Ss(t,e);typeof DOMParser<"u"&&new DOMParser;const Cs=t=>hs(t,(e,s)=>`${s}:${e};`).join(""),Is=JSON.stringify,I=Date.now,E=Symbol,U=E(),Z=E(),st=E(),ue=E(),nt=E(),Es=E(),it=E(),rt=E(),ee=E(),Us=t=>{t.length===1&&t[0]?.constructor===Function&&(t=t[0]());const e=[],s=[];let n=0;for(;n<t.length;n++){const i=t[n];if(i===void 0)break;if(i.constructor===String||i.constructor===Number)e.push(i);else if(i.constructor===Object)break}for(n>0&&s.push(e.join(""));n<t.length;n++){const i=t[n];i instanceof Symbol||s.push(i)}return s},ke=[nt,it,rt,st];let ie=0,Re=I();const As=(t,e)=>{const s=ke[ie],n=Q("log"),i=n!==null&&(n==="*"||n==="true"||new RegExp(n,"gi").test(e));return ie=(ie+1)%ke.length,e+=": ",i?(...r)=>{r.length===1&&r[0]?.constructor===Function&&(r=r[0]());const o=I(),a=o-Re;Re=o,t(s,e,ee,...r.map(c=>{switch(c!=null&&c.constructor===Uint8Array&&(c=Array.from(c)),typeof c){case"string":case"symbol":return c;default:return Is(c)}}),s," +"+a+"ms")}:gs},_s={[U]:S("font-weight","bold"),[Z]:S("font-weight","normal"),[st]:S("color","blue"),[nt]:S("color","green"),[ue]:S("color","grey"),[Es]:S("color","red"),[it]:S("color","purple"),[rt]:S("color","orange"),[ee]:S("color","black")},Ms=t=>{t.length===1&&t[0]?.constructor===Function&&(t=t[0]());const e=[],s=[],n=M();let i=[],r=0;for(;r<t.length;r++){const o=t[r],a=_s[o];if(a!==void 0)n.set(a.left,a.right);else{if(o===void 0)break;if(o.constructor===String||o.constructor===Number){const c=Cs(n);r>0||c.length>0?(e.push("%c"+o),s.push(c)):e.push(o)}else break}}for(r>0&&(i=s,i.unshift(e.join("")));r<t.length;r++){const o=t[r];o instanceof Symbol||i.push(o)}return i},xs=vs?Ms:Us,Ts=(...t)=>{console.log(...xs(t)),Ps.forEach(e=>e.print(t))},Ps=ye(),O=t=>As(Ts,t);class ot{room=null;doc;roomId;matrixClient;opts;onCustomMessage=(e,s)=>{console.warn("[MatrixWebrtcProvider] onCustomMessage not implemented")};onPeerConnected=e=>{console.warn("[MatrixWebrtcProvider] onPeerConnected not implemented")};constructor(e,s,n,i={}){this.doc=e,this.matrixClient=s,this.roomId=n,this.opts={maxConns:20+Math.floor(Math.random()*15),peerOpts:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:global.stun.twilio.com:3478"}]},...i},this.room=new ks(this,s,n,this.opts)}destroy(){this.room&&(this.room.disconnect(),this.room=null)}}class ks{constructor(e,s,n,i){this.provider=e,this.matrixClient=s,this.roomId=n,this.opts=i,this.myPeerId=`${s.getUserId()}-${Date.now()}`,console.log("[MatrixWebrtcRoom] Initializing with peerId:",this.myPeerId),this.connect()}webrtcConns=new Map;myPeerId;connect(){this.matrixClient.on("Room.timeline",this.handleMatrixEvent.bind(this)),this.announcePresence()}disconnect(){console.log("[MatrixWebrtcRoom] Disconnecting"),this.webrtcConns.forEach(e=>e.close()),this.webrtcConns.clear(),this.matrixClient.off("Room.timeline",this.handleMatrixEvent.bind(this))}async announcePresence(){await this.matrixClient.sendEvent(this.roomId,"com.yjs.webrtc.announce",{peerId:this.myPeerId,timestamp:Date.now()})}handleMatrixEvent(e,s){if(s.roomId!==this.roomId)return;const n=e.getSender(),i=e.getContent(),r=e.getType();if(!(n===this.matrixClient.getUserId()&&i.peerId===this.myPeerId))switch(r){case"com.yjs.webrtc.announce":this.webrtcConns.size<(this.opts.maxConns??20)&&this.handlePeerAnnounce(i.peerId,n);break;case"com.yjs.webrtc.signal":i.targetPeer===this.myPeerId&&this.handleWebrtcSignal(i);break}}async handlePeerAnnounce(e,s){if(this.webrtcConns.has(e))return;const n=this.matrixClient.getUserId()<s,i=new De(this,e,s,n,this.matrixClient,this.roomId,this.myPeerId,this.opts.peerOpts);this.webrtcConns.set(e,i),this.setupConnectionHandlers(i),n&&await i.initiate()}handleWebrtcSignal(e){const s=this.webrtcConns.get(e.fromPeer);if(s)s.handleSignal(e.signal);else if(e.signal.type==="offer"){const n=new De(this,e.fromPeer,e.fromUser,!1,this.matrixClient,this.roomId,this.myPeerId,this.opts.peerOpts);this.webrtcConns.set(e.fromPeer,n),this.setupConnectionHandlers(n),n.handleSignal(e.signal)}}setupConnectionHandlers(e){e.onopen=()=>{this.provider.onPeerConnected(s=>e.send(s))},e.onmessage=s=>{this.provider.onCustomMessage(s,n=>e.send(n))},e.onclose=()=>{this.webrtcConns.delete(e.peerId)}}broadcastRoomMessage(e){this.webrtcConns.forEach(s=>{s.connected&&s.send(e)})}get peers(){return this.webrtcConns}}class De{constructor(e,s,n,i,r,o,a,c){this.room=e,this.peerId=s,this.userId=n,this.isInitiator=i,this.matrixClient=r,this.roomId=o,this.myPeerId=a,this.pc=new RTCPeerConnection(c),this.setupPeerConnection()}connected=!1;onopen=null;onmessage=null;onclose=null;pc;channel=null;setupPeerConnection(){this.pc.onicecandidate=e=>{e.candidate&&this.sendSignal({type:"ice-candidate",candidate:e.candidate})},this.pc.ondatachannel=e=>{this.setupDataChannel(e.channel)}}setupDataChannel(e){this.channel=e,e.onopen=()=>{this.connected=!0,this.onopen?.()},e.onmessage=s=>this.onmessage?.(new Uint8Array(s.data)),e.onclose=()=>{this.connected=!1,this.onclose?.()}}async initiate(){this.channel=this.pc.createDataChannel("yjs",{ordered:!0}),this.setupDataChannel(this.channel);const e=await this.pc.createOffer();await this.pc.setLocalDescription(e),this.sendSignal({type:"offer",offer:e})}async handleSignal(e){switch(e.type){case"offer":{if(this.isInitiator){console.debug("[MatrixWebrtcConn] Ignoring colliding offer â€“ I am initiator");return}await this.pc.setRemoteDescription(e.offer);const s=await this.pc.createAnswer();await this.pc.setLocalDescription(s),this.sendSignal({type:"answer",answer:s});break}case"answer":{if(this.pc.signalingState!=="have-local-offer")return;await this.pc.setRemoteDescription(e.answer);break}case"ice-candidate":try{await this.pc.addIceCandidate(e.candidate)}catch{}break}}async sendSignal(e){await this.matrixClient.sendEvent(this.roomId,"com.yjs.webrtc.signal",{fromPeer:this.myPeerId,fromUser:this.matrixClient.getUserId(),targetPeer:this.peerId,signal:e})}send(e){if(this.channel&&this.connected){const s=e.buffer instanceof ArrayBuffer?e:new Uint8Array(new ArrayBuffer(e.byteLength));s!==e&&s.set(e),this.channel.send(s)}}close(){this.pc.close(),this.channel?.close(),this.connected=!1,this.onclose?.()}}function fe(t){const e=t instanceof ArrayBuffer?new Uint8Array(t):t;return Buffer.from(e).toString("base64")}function at(t){const e=Buffer.from(t,"base64");return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}const Rs=O("signed-webrtc"),Le=0,re=1;class ct extends ot{constructor(e,s,n,i,r,o,a){super(e,s,n,a),this.sign=i,this.verify=r,this.awareness=o,e.on("update",this._docUpdateHandler),e.on("destroy",this.destroy.bind(this)),this.awareness&&this.awareness.on("update",this._awarenessUpdateHandler),typeof window<"u"&&window.addEventListener("beforeunload",()=>{this.awareness&&this.awareness.setLocalState(null),this.destroy()})}awareness;onCustomMessage=(e,s)=>{const n=T(e),i=u();switch(w(n)){case Le:const o=X(n);this.verify(o).then(()=>{const a=at(o.message),c=T(a);if(Xe(c,i,this.doc,this)!==Se)throw Rs("error: expect only updates"),new Error("error: only update messages expected")},a=>{console.error("couldn't verify message",a)});break;case re:if(this.awareness){const a=C(n);this.awareness.applyAwarenessUpdateFromBytes(a)}break}};onPeerConnected=e=>{if(console.log("WebRTC peer connected for real-time document sync"),this.awareness&&this.awareness.getLocalState()){const n=u();l(n,re),m(n,this.awareness.encodeAwarenessUpdate()),e(f(n))}};_docUpdateHandler=async(e,s)=>{if(!this.room||s===this)return;const n=u();l(n,Le);const i=u();Ke(i,e);const r={message:fe(f(i))};await this.sign(r),Y(n,r),this.room.broadcastRoomMessage(f(n))};_awarenessUpdateHandler=({added:e,updated:s,removed:n},i)=>{const r=this.room;if(!r||!this.awareness){console.log("[SignedWebrtcProvider] No room or awareness available");return}e.concat(s).concat(n),console.log("[SignedWebrtcProvider] Awareness change:",{added:e,updated:s,removed:n});const o=u();l(o,re),m(o,this.awareness.encodeAwarenessUpdate());const a=f(o);console.log("[SignedWebrtcProvider] Broadcasting awareness update, size:",a.length),r.broadcastRoomMessage(a)};destroy(){this.awareness&&this.awareness.off("update",this._awarenessUpdateHandler),this.doc.off("update",this._docUpdateHandler),this.doc.off("destroy",this.destroy),super.destroy()}}class Ds{constructor(e){this.doc=e,this.clientId=this.generateClientId(),this.cleanupInterval=setInterval(()=>this.cleanupStaleStates(),3e4),this.debug&&console.log("[BlockNoteAwareness] Initialized with clientId:",this.clientId)}states=new Map;localState=null;clientId;listeners={};cleanupInterval;debug=!0;generateClientId(){return Date.now()+"-"+Math.random().toString(36).substr(2,9)}get clientID(){return this.clientId}setLocalState(e){this.debug&&console.log("[BlockNoteAwareness] setLocalState called:",e),e===null?(this.localState=null,this.states.delete(this.clientId)):(this.localState={...this.localState,...e,timestamp:Date.now()},this.states.set(this.clientId,this.localState));const s={added:[],updated:[this.clientId],removed:e===null?[this.clientId]:[]};this.emit("change",s),this.emit("update",s)}setLocalStateField(e,s){this.debug&&console.log("[BlockNoteAwareness] setLocalStateField:",e,s),this.localState||(this.localState={timestamp:Date.now()}),this.localState[e]=s,this.localState.timestamp=Date.now(),this.states.set(this.clientId,this.localState);const n={added:[],updated:[this.clientId],removed:[]};this.emit("change",n),this.emit("update",n)}getStates(){return new Map(this.states)}getLocalState(){return this.localState}applyAwarenessUpdate(e){const{clientId:s,state:n}=e;if(this.debug&&console.log("[BlockNoteAwareness] applyAwarenessUpdate:",e),s===this.clientId)return;const i=this.states.has(s);n===null?(this.states.delete(s),i&&this.emit("change",{added:[],updated:[],removed:[s]})):(this.states.set(s,n),this.emit("change",{added:i?[]:[s],updated:i?[s]:[],removed:[]}))}encodeAwarenessUpdate(){if(!this.localState)return new Uint8Array(0);const e={clientId:this.clientId,state:this.localState},s=JSON.stringify(e);return this.debug&&console.log("[BlockNoteAwareness] Encoding update:",e),new TextEncoder().encode(s)}applyAwarenessUpdateFromBytes(e){try{const s=new TextDecoder().decode(e),n=JSON.parse(s);this.debug&&console.log("[BlockNoteAwareness] Received update bytes:",n),this.applyAwarenessUpdate(n)}catch(s){console.error("[BlockNoteAwareness] Failed to decode awareness update:",s)}}cleanupStaleStates(){const e=Date.now(),s=30*1e3,n=[];this.states.forEach((i,r)=>{r!==this.clientId&&e-i.timestamp>s&&n.push(r)}),n.length>0&&(this.debug&&console.log("[BlockNoteAwareness] Cleaning up stale states:",n),n.forEach(i=>this.states.delete(i)),this.emit("change",{added:[],updated:[],removed:n}))}on(e,s){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(s),this.debug&&console.log("[BlockNoteAwareness] Listener added for event:",e)}off(e,s){if(this.listeners[e]){const n=this.listeners[e].indexOf(s);n>-1&&this.listeners[e].splice(n,1)}}emit(e,s){this.debug&&console.log("[BlockNoteAwareness] Emitting event:",e,s),this.listeners[e]&&this.listeners[e].forEach(n=>{try{n(s)}catch(i){console.error("[BlockNoteAwareness] Error in event listener:",i)}})}destroy(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.states.clear(),this.listeners={},this.localState=null,this.debug&&console.log("[BlockNoteAwareness] Destroyed")}}const Ls={flushInterval:process.env.NODE_ENV==="test"?100:500,retryIfForbiddenInterval:1e3*30};class Bs extends y.lifecycle.Disposable{constructor(e,s,n={}){super(),this.matrixClient=e,this.translator=s,this.opts={...Ls,...n},this.throttledFlushUpdatesToMatrix=vt.throttle(this.flushUpdatesToMatrix,this.canWrite?this.opts.flushInterval:this.opts.retryIfForbiddenInterval)}pendingUpdates=[];isSendingUpdates=!1;_canWrite=!0;retryTimeoutHandler;roomId;_onCanWriteChanged=this._register(new y.event.Emitter);onCanWriteChanged=this._onCanWriteChanged.event;_onSentAllEvents=this._register(new y.event.Emitter);onSentAllEvents=this._onSentAllEvents.event;throttledFlushUpdatesToMatrix;opts;setCanWrite(e){this._canWrite!==e&&(this._canWrite=e,this._onCanWriteChanged.fire())}flushUpdatesToMatrix=async()=>{if(this.isSendingUpdates||!this.pendingUpdates.length||!this.roomId)return;this.isSendingUpdates=!0;const e=p.mergeUpdates(this.pendingUpdates);this.pendingUpdates=[];let s=!1;try{console.log("Sending updates"),await this.translator.sendUpdate(this.matrixClient,this.roomId,e),this.setCanWrite(!0),console.log("sent updates")}catch(n){if(n.errcode==="M_FORBIDDEN"){console.warn("not allowed to edit document",n),this.setCanWrite(!1);try{await this.matrixClient.joinRoom(this.roomId),console.log("joined room",this.roomId),s=!0}catch(i){console.warn("failed to join room",i)}}else console.error("error sending updates",n);this.pendingUpdates.unshift(e)}finally{this.isSendingUpdates=!1}this.pendingUpdates.length?this.retryTimeoutHandler=setTimeout(()=>{this.throttledFlushUpdatesToMatrix()},s?0:this.canWrite?this.opts.flushInterval:this.opts.retryIfForbiddenInterval):(console.log("_onSentAllEvents"),this._onSentAllEvents.fire())};async initialize(e){this.roomId=e,this.throttledFlushUpdatesToMatrix()}get canWrite(){return this._canWrite}writeUpdate(e){this.pendingUpdates.push(e),this.throttledFlushUpdatesToMatrix()}async waitForFlush(){!this.pendingUpdates.length&&!this.isSendingUpdates||await y.event.Event.toPromise(this.onSentAllEvents)}dispose(){super.dispose(),clearTimeout(this.retryTimeoutHandler),this.throttledFlushUpdatesToMatrix.cancel()}}function Os(t,e){return Ws(new DataView(t),new DataView(e))}function Ws(t,e){if(t.byteLength!==e.byteLength)return!1;for(let s=0;s<t.byteLength;s++)if(t.getUint8(s)!==e.getUint8(s))return!1;return!0}const W="m.room.message",Fs={updatesAsRegularMessages:!1,updateEventType:"matrix-crdt.doc_update",snapshotEventType:"matrix-crdt.doc_snapshot"};class Ns{opts;constructor(e={}){this.opts={...Fs,...e}}async sendUpdate(e,s,n){const i=fe(n),r={update:i};if(this.opts.updatesAsRegularMessages){const o={body:this.opts.updateEventType+": "+i,msgtype:this.opts.updateEventType,...r};"scheduler"in e&&(e.scheduler=void 0),await e.sendEvent(s,W,o,"")}else await e.sendEvent(s,this.opts.updateEventType,r,"")}async sendSnapshot(e,s,n,i){const r=fe(n),o={update:r,last_event_id:i};if(this.opts.updatesAsRegularMessages){const a={body:this.opts.snapshotEventType+": "+r,msgtype:this.opts.snapshotEventType,...o};"scheduler"in e&&(e.scheduler=void 0),await e.sendEvent(s,W,a,"")}else await e.sendEvent(s,this.opts.snapshotEventType,o,"")}isUpdateEvent(e){return this.opts.updatesAsRegularMessages?e.type===W&&e.content.msgtype===this.opts.updateEventType:e.type===this.opts.updateEventType}isSnapshotEvent(e){return this.opts.updatesAsRegularMessages?e.type===W&&e.content.msgtype===this.opts.snapshotEventType:e.type===this.opts.snapshotEventType}get WrappedEventType(){return this.opts.updatesAsRegularMessages?W:this.opts.updateEventType}}const zs={enableExperimentalWebrtcSync:!1,enableAwareness:!1,reader:{},writer:{},translator:{}};class js extends y.lifecycle.Disposable{constructor(e,s,n,i={}){super(),this.doc=e,this.matrixClient=s,this.room=n,this.opts={...zs,...i},this.translator=new Ns(this.opts.translator),this.throttledWriter=new Bs(this.matrixClient,this.translator,this.opts.writer),this.opts.enableAwareness&&(this.awareness=new Ds(e)),e.on("update",this.documentUpdateListener)}disposed=!1;_roomId;initializeTimeoutHandler;initializedResolve;initializedPromise=new Promise(e=>{this.initializedResolve=e});webrtcProvider;reader;throttledWriter;translator;awareness;_onDocumentAvailable=this._register(new y.event.Emitter);_onDocumentUnavailable=this._register(new y.event.Emitter);_onReceivedEvents=this._register(new y.event.Emitter);opts;onDocumentAvailable=this._onDocumentAvailable.event;onReceivedEvents=this._onReceivedEvents.event;onDocumentUnavailable=this._onDocumentUnavailable.event;get onCanWriteChanged(){return this.throttledWriter.onCanWriteChanged}get canWrite(){return this.throttledWriter.canWrite}get roomId(){return this._roomId}get matrixReader(){return this.reader}get awarenessInstance(){return this.awareness}totalEventsReceived=0;documentUpdateListener=async(e,s)=>{s===this||this.webrtcProvider&&s===this.webrtcProvider||s?.provider||this.throttledWriter.writeUpdate(e)};processIncomingEvents=(e,s=!1)=>{e=e.filter(o=>!(!this.translator.isUpdateEvent(o)&&!this.translator.isSnapshotEvent(o))),this.totalEventsReceived+=e.length;const n=e.map(o=>new Uint8Array(at(o.content.update))),i=p.mergeUpdates(n);if(!n.length)return i;if(p.applyUpdate(this.doc,i,this),s){const o=e[e.length-1],a=p.encodeStateAsUpdate(this.doc);this.translator.sendSnapshot(this.matrixClient,this._roomId,a,o.event_id).catch(c=>{console.error("failed to send snapshot")})}return e.filter(o=>o.user_id!==this.matrixClient.credentials.userId).length&&this._onReceivedEvents.fire(),i};async initializeWebrtc(){if(!this._roomId)throw new Error("not initialized");if(!this.reader)throw new Error("needs reader to initialize webrtc");const e=this._register(new ze(this.matrixClient,this.reader));await e.initialize();const s=bt.createClient({baseUrl:this.matrixClient.baseUrl||this.matrixClient.clientOpts?.baseUrl,accessToken:this.matrixClient.getAccessToken?this.matrixClient.getAccessToken():this.matrixClient.credentials?.accessToken,userId:this.matrixClient.getUserId()||void 0,timelineSupport:!0});let n;try{const i={room:{timeline:{limit:10,types:["com.yjs.webrtc.*"]}},presence:{types:[]},account_data:{types:[]}};n=await s.createFilter(i)}catch{}s.startClient({filter:n,initialSyncLimit:10}),await new Promise(i=>s.once("sync",r=>r==="PREPARED"&&i())),this._register({dispose:()=>s.stopClient()}),this.webrtcProvider=new ct(this.doc,s,this._roomId,async i=>{await Fe(this.matrixClient,i)},async i=>{await Ne(this.matrixClient,e,i,this.translator.WrappedEventType)},this.awareness)}async initializeNoCatch(){const e=this.room.type==="id"?this.room.id:this.room.alias;try{if(this.room.type==="id")this._roomId=this.room.id;else if(this.room.type==="alias"){const h=await this.matrixClient.getRoomIdForAlias(this.room.alias);this._roomId=h.room_id}if(!this._roomId)throw new Error("error receiving room id");console.log("room resolved",this._roomId),await this.throttledWriter.initialize(this._roomId)}catch(h){let b=5e3;h.errcode==="M_NOT_FOUND"?(console.log("room not found",e),this._onDocumentUnavailable.fire()):h.name==="ConnectionError"?console.log("room not found (offline)",e):(console.error("error retrieving room",e,h),b=30*1e3,this._onDocumentUnavailable.fire()),this.initializeTimeoutHandler=setTimeout(()=>{this.initialize()},b);return}let s=p.encodeStateAsUpdate(this.doc);const n=p.encodeStateVectorFromUpdate(s),i=p.diffUpdate(s,n);let r=p.snapshot(this.doc);const o=await this.initializeReader();this._onDocumentAvailable.fire();const a=p.encodeStateVectorFromUpdate(o),c=p.diffUpdate(s,a);if(Os(i.buffer,c.buffer)){let h=new p.Doc;p.applyUpdate(h,o);let b=p.snapshot(h);if(Vs(b,r)){this.initializedResolve();return}}c.length>2&&this.throttledWriter.writeUpdate(c),this.initializedResolve()}async initializeReader(){if(this.reader)throw new Error("already initialized reader");if(!this._roomId)throw new Error("no roomId");this.reader=this._register(new Et(this.matrixClient,this._roomId,this.translator,this.opts.reader)),this._register(this.reader.onEvents(s=>this.processIncomingEvents(s.events,s.shouldSendSnapshot)));const e=await this.reader.getInitialDocumentUpdateEvents();return this.reader.startPolling(),this.processIncomingEvents(e)}async waitForFlush(){await this.initializedPromise,await this.throttledWriter.waitForFlush()}async initialize(){try{await this.initializeNoCatch(),await this.initializedPromise,!this.disposed&&this.opts.enableExperimentalWebrtcSync&&await this.initializeWebrtc()}catch(e){throw console.error(e),e}}dispose(){super.dispose(),this.disposed=!0,this.webrtcProvider?.destroy(),this.reader?.dispose(),this.awareness?.destroy(),clearTimeout(this.initializeTimeoutHandler),this.doc.off("update",this.documentUpdateListener)}}function Vs(t,e){for(const[s,n]of e.ds.clients.entries()){const i=t.ds.clients.get(s)||[];if(n.length>i.length)return!1;for(let r=0;r<n.length;r++){const o=n[r],a=i[r];if(o.clock!==a.clock||o.len!==a.len)return!1}}return!0}async function $s(t,e,s){try{const n=[];return n.push({type:"m.room.guest_access",state_key:"",content:{guest_access:"forbidden"}}),n.push({type:"m.room.join_rules",content:{join_rule:s==="public-read-write"?"public":"invite"}}),n.push({type:"m.room.history_visibility",content:{history_visibility:"world_readable"}}),{status:"ok",roomId:(await t.createRoom({room_alias_name:e,visibility:"public",name:e,topic:"",initial_state:n})).room_id}}catch(n){return n.errcode==="M_ROOM_IN_USE"?"already-exists":n.name==="ConnectionError"?"offline":{status:"error",error:n}}}async function Hs(t,e){let s;try{s=await t.getStateEvent(e,"m.room.join_rules")}catch(n){return{status:"error",error:n}}if(s.join_rule==="public")return"public-read-write";if(s.join_rule==="invite")return"public-read";throw new Error("unsupported join_rule")}async function qs(t,e,s){try{return await t.sendStateEvent(e,"m.room.join_rules",{join_rule:s==="public-read-write"?"public":"invite"},""),{status:"ok",roomId:e}}catch(n){return n.name==="ConnectionError"?"offline":{status:"error",error:n}}}class Ie{constructor(){this._observers=M()}on(e,s){$(this._observers,e,ye).add(s)}once(e,s){const n=(...i)=>{this.off(e,n),s(...i)};this.on(e,n)}off(e,s){const n=this._observers.get(e);n!==void 0&&(n.delete(s),n.size===0&&this._observers.delete(e))}emit(e,s){return Tt((this._observers.get(e)||M()).values()).forEach(n=>n(...s))}destroy(){this._observers=M()}}const oe=3e4;class Gs extends Ie{constructor(e){super(),this.doc=e,this.clientID=e.clientID,this.states=new Map,this.meta=new Map,this._checkInterval=setInterval(()=>{const s=I();this.getLocalState()!==null&&oe/2<=s-this.meta.get(this.clientID).lastUpdated&&this.setLocalState(this.getLocalState());const n=[];this.meta.forEach((i,r)=>{r!==this.clientID&&oe<=s-i.lastUpdated&&this.states.has(r)&&n.push(r)}),n.length>0&&lt(this,n,"timeout")},D(oe/10)),e.on("destroy",()=>{this.destroy()}),this.setLocalState({})}destroy(){this.emit("destroy",[this]),this.setLocalState(null),super.destroy(),clearInterval(this._checkInterval)}getLocalState(){return this.states.get(this.clientID)||null}setLocalState(e){const s=this.clientID,n=this.meta.get(s),i=n===void 0?0:n.clock+1,r=this.states.get(s);e===null?this.states.delete(s):this.states.set(s,e),this.meta.set(s,{clock:i,lastUpdated:I()});const o=[],a=[],c=[],h=[];e===null?h.push(s):r==null?e!=null&&o.push(s):(a.push(s),z(r,e)||c.push(s)),(o.length>0||c.length>0||h.length>0)&&this.emit("change",[{added:o,updated:c,removed:h},"local"]),this.emit("update",[{added:o,updated:a,removed:h},"local"])}setLocalStateField(e,s){const n=this.getLocalState();n!==null&&this.setLocalState({...n,[e]:s})}getStates(){return this.states}}const lt=(t,e,s)=>{const n=[];for(let i=0;i<e.length;i++){const r=e[i];if(t.states.has(r)){if(t.states.delete(r),r===t.clientID){const o=t.meta.get(r);t.meta.set(r,{clock:o.clock+1,lastUpdated:I()})}n.push(r)}}n.length>0&&(t.emit("change",[{added:[],updated:[],removed:n},s]),t.emit("update",[{added:[],updated:[],removed:n},s]))},Be=(t,e,s=t.states)=>{const n=e.length,i=u();l(i,n);for(let r=0;r<n;r++){const o=e[r],a=s.get(o)||null,c=t.meta.get(o).clock;l(i,o),l(i,c),L(i,JSON.stringify(a))}return f(i)},Js=(t,e,s)=>{const n=T(e),i=I(),r=[],o=[],a=[],c=[],h=w(n);for(let b=0;b<h;b++){const g=w(n);let H=w(n);const A=JSON.parse(V(n)),q=t.meta.get(g),mt=t.states.get(g),Ue=q===void 0?0:q.clock;(Ue<H||Ue===H&&A===null&&t.states.has(g))&&(A===null?g===t.clientID&&t.getLocalState()!=null?H++:t.states.delete(g):t.states.set(g,A),t.meta.set(g,{clock:H,lastUpdated:i}),q===void 0&&A!==null?r.push(g):q!==void 0&&A===null?c.push(g):A!==null&&(z(A,mt)||a.push(g),o.push(g)))}(r.length>0||a.length>0||c.length>0)&&t.emit("change",[{added:r,updated:a,removed:c},s]),(r.length>0||o.length>0||c.length>0)&&t.emit("update",[{added:r,updated:o,removed:c},s])},te=new Map,x=new Map;function pe(t){te.forEach(e=>{e.connected&&(e.send({type:"subscribe",topics:[t.name]}),t.webrtcConns.size<t.provider.maxConns&&e.publishSignalingMessage(t,{type:"announce",from:t.peerId}))})}const Ys=crypto.getRandomValues.bind(crypto),Ks=Math.random,Xs=()=>Ys(new Uint32Array(1))[0],Qs="10000000-1000-4000-8000"+-1e11,Zs=()=>Qs.replace(/[018]/g,t=>(t^Xs()&15>>t/4).toString(16));Promise.all.bind(Promise);const en=t=>Promise.reject(t),tn=(t,e)=>{const s=le(t).buffer,n=le(e).buffer,i=s instanceof ArrayBuffer?s:new ArrayBuffer(s.byteLength),r=n instanceof ArrayBuffer?n:new ArrayBuffer(n.byteLength);return s!==i&&new Uint8Array(i).set(new Uint8Array(s)),n!==r&&new Uint8Array(r).set(new Uint8Array(n)),crypto.subtle.importKey("raw",i,"PBKDF2",!1,["deriveKey"]).then(o=>crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:1e5,hash:"SHA-256"},o,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]))},ht=async(t,e)=>{if(!e)return t;const s=crypto.getRandomValues(new Uint8Array(12)),n=t.buffer instanceof ArrayBuffer?t:new Uint8Array(new ArrayBuffer(t.byteLength));return n!==t&&n.set(t),crypto.subtle.encrypt({name:"AES-GCM",iv:s},e,n).then(i=>{const r=u();return L(r,"AES-GCM"),m(r,s),m(r,new Uint8Array(i)),f(r)})},sn=(t,e)=>{const s=u();return Y(s,t),ht(f(s),e)},dt=async(t,e)=>{if(!e)return t;const s=T(t);V(s)!=="AES-GCM"&&en(ne("Unknown encryption algorithm"));const i=C(s),r=C(s),o=i.buffer instanceof ArrayBuffer?i:new Uint8Array(new ArrayBuffer(i.byteLength)),a=r.buffer instanceof ArrayBuffer?r:new Uint8Array(new ArrayBuffer(r.byteLength));return o!==i&&o.set(i),a!==r&&a.set(r),crypto.subtle.decrypt({name:"AES-GCM",iv:o},e,a).then(c=>new Uint8Array(c))},nn=(t,e)=>dt(t,e).then(s=>X(T(new Uint8Array(s)))),rn=t=>new Uint8Array(t),on=(t,e,s)=>new Uint8Array(t,e,s),an=t=>new Uint8Array(t),cn=t=>{let e="";for(let s=0;s<t.byteLength;s++)e+=kt(t[s]);return btoa(e)},ln=t=>Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("base64"),hn=t=>{const e=atob(t),s=rn(e.length);for(let n=0;n<e.length;n++)s[n]=e.charCodeAt(n);return s},dn=t=>{const e=Buffer.from(t,"base64");return on(e.buffer,e.byteOffset,e.byteLength)},ut=et?cn:ln,ft=et?hn:dn,pt=new Map;class un{constructor(e){this.room=e,this.onmessage=null,this._onChange=s=>s.key===e&&this.onmessage!==null&&this.onmessage({data:ft(s.newValue||"")}),us(this._onChange)}postMessage(e){Ze.setItem(this.room,ut(an(e)))}close(){fs(this._onChange)}}const fn=typeof BroadcastChannel>"u"?un:BroadcastChannel,Ee=t=>$(pt,t,()=>{const e=ye(),s=new fn(t);return s.onmessage=n=>e.forEach(i=>i(n.data,"broadcastchannel")),{bc:s,subs:e}}),pn=(t,e)=>(Ee(t).subs.add(e),e),mn=(t,e)=>{const s=Ee(t),n=s.subs.delete(e);return n&&s.subs.size===0&&(s.bc.close(),pt.delete(t)),n},gn=(t,e,s=null)=>{const n=Ee(t);n.bc.postMessage(e),n.subs.forEach(i=>i(e,s))},yn=()=>{let t=!0;return(e,s)=>{if(t){t=!1;try{e()}finally{t=!0}}else s!==void 0&&s()}},ae=4,G=5,wn=O("y-webrtc");class bn{constructor(e,s,n,i,r){this.provider=e,this.onCustomMessage=s,this.onPeerConnected=n,this.name=i,this.key=r}peerId=Zs();synced=!1;webrtcConns=new Map;bcConns=new Set;mux=yn();bcconnected=!1;_bcSubscriber=e=>dt(new Uint8Array(e),this.key).then(s=>this.mux(()=>{this.readMessage(s,n=>{this.broadcastBcMessage(f(n))})}));readMessage=(e,s)=>{const n=T(e),i=u(),r=w(n),o=a=>{l(i,G),m(i,a),s(i)};switch(r){case G:this.onCustomMessage(C(n),o);break;case ae:{const a=K(n)===1,c=V(n);if(c!==this.peerId&&(this.bcConns.has(c)&&!a||!this.bcConns.has(c)&&a)){const h=[],b=[];a?(this.bcConns.add(c),b.push(c),this.onPeerConnected(o)):(this.bcConns.delete(c),h.push(c)),this.provider.emit("peers",[{added:b,removed:h,webrtcPeers:Array.from(this.webrtcConns.keys()),bcPeers:Array.from(this.bcConns)}]),this.broadcastBcPeerId()}break}default:console.error("Unable to compute message");return}};broadcastBcPeerId(){if(this.provider.filterBcConns){const e=u();l(e,ae),_e(e,1),L(e,this.peerId),this.broadcastBcMessage(f(e))}}broadcastWebrtcConn(e){wn("broadcast message in ",U,this.name,Z),this.webrtcConns.forEach(s=>{try{s.peer.send(e)}catch{}})}broadcastRoomMessage(e){const s=u();l(s,G),m(s,e);const n=f(s);this.bcconnected&&this.broadcastBcMessage(n),this.broadcastWebrtcConn(n)}broadcastBcMessage(e){return ht(e,this.key).then(s=>this.mux(()=>gn(this.name,s)))}connect(){pe(this);const e=this.name;pn(e,this._bcSubscriber),this.bcconnected=!0,this.broadcastBcPeerId()}disconnect(){te.forEach(s=>{s.connected&&s.send({type:"unsubscribe",topics:[this.name]})});const e=u();l(e,ae),_e(e,0),L(e,this.peerId),this.broadcastBcMessage(f(e)),mn(this.name,this._bcSubscriber),this.bcconnected=!1,this.webrtcConns.forEach(s=>s.destroy())}destroy(){this.disconnect()}}const vn=1200,Sn=2500,se=3e4,me=t=>{if(t.shouldConnect&&t.ws===null){const e=new WebSocket(t.url),s=t.binaryType;let n=null;s&&(e.binaryType=s),t.ws=e,t.connecting=!0,t.connected=!1,e.onmessage=o=>{t.lastMessageReceived=I();const a=o.data,c=typeof a=="string"?JSON.parse(a):a;c&&c.type==="pong"&&(clearTimeout(n),n=setTimeout(r,se/2)),t.emit("message",[c,t])};const i=o=>{t.ws!==null&&(t.ws=null,t.connecting=!1,t.connected?(t.connected=!1,t.emit("disconnect",[{type:"disconnect",error:o},t])):t.unsuccessfulReconnects++,setTimeout(me,Ve(_t(t.unsuccessfulReconnects+1)*vn,Sn),t)),clearTimeout(n)},r=()=>{t.ws===e&&t.send({type:"ping"})};e.onclose=()=>i(null),e.onerror=o=>i(o),e.onopen=()=>{t.lastMessageReceived=I(),t.connecting=!1,t.connected=!0,t.unsuccessfulReconnects=0,t.emit("connect",[{type:"connect"},t]),n=setTimeout(r,se/2)}}};class Cn extends Ie{constructor(e,{binaryType:s}={}){super(),this.url=e,this.ws=null,this.binaryType=s||null,this.connected=!1,this.connecting=!1,this.unsuccessfulReconnects=0,this.lastMessageReceived=0,this.shouldConnect=!0,this._checkInterval=setInterval(()=>{this.connected&&se<I()-this.lastMessageReceived&&this.ws.close()},se/2),me(this)}send(e){this.ws&&this.ws.send(JSON.stringify(e))}destroy(){clearInterval(this._checkInterval),this.disconnect(),super.destroy()}disconnect(){this.shouldConnect=!1,this.ws!==null&&this.ws.close()}connect(){this.shouldConnect=!0,!this.connected&&this.ws===null&&me(this)}}const P=O("y-webrtc");class Oe{constructor(e,s,n,i){this.remotePeerId=n,this.room=i,P("establishing connection to ",U,n),this.peer=new wt({initiator:s,...i.provider.peerOpts}),this.peer.on("signal",r=>{e.publishSignalingMessage(i,{to:n,from:i.peerId,type:"signal",signal:r})}),this.peer.on("connect",()=>{P("connected to ",U,n),this.connected=!0,i.onPeerConnected(r=>{const o=u();l(o,G),m(o,r),this.sendWebrtcConn(o)})}),this.peer.on("close",()=>{this.connected=!1,this.closed=!0,i.webrtcConns.has(this.remotePeerId)&&(i.webrtcConns.delete(this.remotePeerId),i.provider.emit("peers",[{removed:[this.remotePeerId],added:[],webrtcPeers:Array.from(i.webrtcConns.keys()),bcPeers:Array.from(i.bcConns)}])),this.peer.destroy(),P("closed connection to ",U,n),pe(i)}),this.peer.on("error",r=>{P("Error in connection to ",U,n,": ",r),pe(i)}),this.peer.on("data",r=>{P("received message from ",U,this.remotePeerId,ue," (",i.name,")",Z,ee),this.room.readMessage(r,o=>{this.sendWebrtcConn(o)})})}closed=!1;connected=!1;synced=!1;sendWebrtcConn(e){P("send message to ",U,this.remotePeerId,Z,ue," (",this.room.name,")",ee);try{this.peer.send(f(e))}catch{}}peer;destroy(){this.peer.destroy()}}const We=O("y-webrtc");class In extends Cn{providers=new Set;constructor(e){super(e),this.on("connect",()=>{We(`connected (${e})`);const s=Array.from(x.keys());this.send({type:"subscribe",topics:s}),x.forEach(n=>this.publishSignalingMessage(n,{type:"announce",from:n.peerId}))}),this.on("message",s=>{switch(s.type){case"publish":{const n=s.topic,i=x.get(n);if(i==null||typeof n!="string")return;const r=o=>{const a=i.webrtcConns,c=i.peerId;if(o==null||o.from===c||o.to!==void 0&&o.to!==c||i.bcConns.has(o.from))return;const h=a.has(o.from)?()=>{}:()=>i.provider.emit("peers",[{removed:[],added:[o.from],webrtcPeers:Array.from(i.webrtcConns.keys()),bcPeers:Array.from(i.bcConns)}]);switch(o.type){case"announce":a.size<i.provider.maxConns&&($(a,o.from,()=>new Oe(this,!0,o.from,i)),h());break;case"signal":o.to===c&&($(a,o.from,()=>new Oe(this,!1,o.from,i)).peer.signal(o.signal),h());break}};i.key?typeof s.data=="string"&&nn(ft(s.data),i.key).then(r):r(s.data)}}}),this.on("disconnect",()=>We(`disconnect (${e})`))}publishSignalingMessage=(e,s)=>{e.key?sn(s,e.key).then(n=>{this.send({type:"publish",topic:e.name,data:ut(n)})}):this.send({type:"publish",topic:e.name,data:s})}}O("y-webrtc");const En=(t,e,s,n,i)=>{if(x.has(n))throw ne(`A Yjs Doc connected to room "${n}" already exists!`);const r=new bn(t,e,s,n,i);return x.set(n,r),r};class Un extends Ie{constructor(e,{signaling:s=["wss://signaling.yjs.dev","wss://y-webrtc-signaling-eu.herokuapp.com","wss://y-webrtc-signaling-us.herokuapp.com"],password:n=void 0,maxConns:i=20+D(Ks()*15),filterBcConns:r=!0,peerOpts:o={}}={}){super(),this.roomName=e,this.filterBcConns=r,this.shouldConnect=!1,this.signalingUrls=s,this.signalingConns=[],this.maxConns=i,this.peerOpts={iceServers:[]},this.key=n?tn(n,e):Promise.resolve(void 0),this.key.then(a=>{this.room=En(this,this.onCustomMessage,this.onPeerConnected,e,a),this.shouldConnect?this.room.connect():this.room.disconnect()}),this.connect()}shouldConnect=!1;filterBcConns=!0;signalingUrls;signalingConns;peerOpts;maxConns;key;room;get connected(){return this.room!==null&&this.shouldConnect}connect(){this.shouldConnect=!0,this.signalingUrls.forEach(e=>{const s=$(te,e,()=>new In(e));this.signalingConns.push(s),s.providers.add(this)}),this.room&&this.room.connect()}disconnect(){this.shouldConnect=!1,this.signalingConns.forEach(e=>{e.providers.delete(this),e.providers.size===0&&(e.destroy(),te.delete(e.url))}),this.room&&this.room.disconnect()}destroy(){this.key.then(()=>{this.room?.destroy(),x.delete(this.roomName)}),super.destroy()}}const An=O("y-webrtc"),F=0,_n=3,J=1;class Mn extends Un{constructor(e,s,n,i=new Gs(s)){super(e,n),this.doc=s,this.awareness=i,s.on("destroy",this.destroy.bind(this)),this.doc.on("update",this._docUpdateHandler),this.awareness.on("update",this._awarenessUpdateHandler),window.addEventListener("beforeunload",()=>{lt(this.awareness,[s.clientID],"window unload"),x.forEach(r=>{r.disconnect()})})}onCustomMessage=(e,s)=>{const n=T(e),i=u();switch(w(n)){case F:{l(i,F),Xe(n,i,this.doc,this)===ve&&s(f(i));break}case J:Js(this.awareness,C(n),this);break}};onPeerConnected=e=>{const s=u();l(s,F),os(s,this.doc),e(f(s));const n=u(),i=this.awareness.getStates();i.size>0&&(l(n,J),m(n,Be(this.awareness,Array.from(i.keys()))),e(f(n)))};_docUpdateHandler=(e,s)=>{if(!this.room)return;const n=u();l(n,F),Ke(n,e),this.room.broadcastRoomMessage(f(n))};_awarenessUpdateHandler=({added:e,updated:s,removed:n},i)=>{if(!this.room)return;const r=e.concat(s).concat(n);An("awareness change ",{added:e,updated:s,removed:n},"local",this.awareness.clientID);const o=u();l(o,J),m(o,Be(this.awareness,r)),this.room.broadcastRoomMessage(f(o))};destroy(){this.doc.off("update",this._docUpdateHandler),this.awareness.off("update",this._awarenessUpdateHandler),this.doc.off("destroy",this.destroy),super.destroy()}}class xn{constructor(e){this.doc=e,this.clientId=this.generateClientId(),this.cleanupInterval=setInterval(()=>this.cleanupStaleStates(),3e4)}states=new Map;localState=null;clientId;listeners={};cleanupInterval;generateClientId(){return Date.now()+"-"+Math.random().toString(36).substr(2,9)}get clientID(){return this.clientId}setLocalState(e){e===null?(this.localState=null,this.states.delete(this.clientId)):(this.localState={...this.localState,...e,timestamp:Date.now()},this.states.set(this.clientId,this.localState)),this.emit("change",{added:[],updated:[this.clientId],removed:e===null?[this.clientId]:[]}),this.emit("update",{added:[],updated:[this.clientId],removed:e===null?[this.clientId]:[]})}setLocalStateField(e,s){this.localState||(this.localState={timestamp:Date.now()}),this.localState[e]=s,this.localState.timestamp=Date.now(),this.states.set(this.clientId,this.localState),this.emit("change",{added:[],updated:[this.clientId],removed:[]}),this.emit("update",{added:[],updated:[this.clientId],removed:[]})}getStates(){return new Map(this.states)}getLocalState(){return this.localState}applyAwarenessUpdate(e){const{clientId:s,state:n}=e;if(s===this.clientId)return;const i=this.states.has(s);n===null?(this.states.delete(s),i&&this.emit("change",{added:[],updated:[],removed:[s]})):(this.states.set(s,n),this.emit("change",{added:i?[]:[s],updated:i?[s]:[],removed:[]}))}encodeAwarenessUpdate(){if(!this.localState)return new Uint8Array(0);const e={clientId:this.clientId,state:this.localState},s=JSON.stringify(e);return new TextEncoder().encode(s)}applyAwarenessUpdateFromBytes(e){try{const s=new TextDecoder().decode(e),n=JSON.parse(s);this.applyAwarenessUpdate(n)}catch(s){console.error("Failed to decode awareness update:",s)}}cleanupStaleStates(){const e=Date.now(),s=30*1e3,n=[];this.states.forEach((i,r)=>{r!==this.clientId&&e-i.timestamp>s&&n.push(r)}),n.length>0&&(n.forEach(i=>this.states.delete(i)),this.emit("change",{added:[],updated:[],removed:n}))}on(e,s){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(s)}off(e,s){if(this.listeners[e]){const n=this.listeners[e].indexOf(s);n>-1&&this.listeners[e].splice(n,1)}}emit(e,s){this.listeners[e]&&this.listeners[e].forEach(n=>n(s))}destroy(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.states.clear(),this.listeners={},this.localState=null}}exports.DocWebrtcProvider=Mn;exports.MatrixMemberReader=ze;exports.MatrixProvider=js;exports.MatrixWebrtcProvider=ot;exports.SignedWebrtcProvider=ct;exports.SimpleAwareness=xn;exports.createMatrixRoom=$s;exports.getMatrixRoomAccess=Hs;exports.messageAwareness=J;exports.messageQueryAwareness=_n;exports.messageSync=F;exports.signObject=Fe;exports.updateMatrixRoomAccess=qs;exports.verifyObject=Ne;
