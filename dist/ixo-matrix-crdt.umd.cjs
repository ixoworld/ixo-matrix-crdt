(function(l,v){typeof exports=="object"&&typeof module<"u"?v(exports,require("matrix-js-sdk"),require("vscode-lib"),require("yjs"),require("another-json"),require("lodash"),require("simple-peer")):typeof define=="function"&&define.amd?define(["exports","matrix-js-sdk","vscode-lib","yjs","another-json","lodash","simple-peer"],v):(l=typeof globalThis<"u"?globalThis:l||self,v(l["matrix-crdt"]={},l.sdk,l.vscodeLib,l.Y,null,l._,l.Peer))})(this,(function(l,v,y,gt,In,yt,wt){"use strict";function re(t){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(t){for(const s in t)if(s!=="default"){const n=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(e,s,n.get?n:{enumerable:!0,get:()=>t[s]})}}return e.default=t,Object.freeze(e)}const bt=re(v),m=re(gt),vt=re(yt);async function Ae(t,e){const s=t.getUserId();if(!s)throw new Error("User ID not available");e.userId=s,e.timestamp=Date.now(),console.log(`Tagged WebRTC message from user: ${s}`)}async function _e(t,e,s,n){if(!s.userId)throw new Error("WebRTC message missing user identification");if(s.timestamp){const r=Date.now()-s.timestamp,o=60*1e3;if(r>o){console.warn(`Old WebRTC message ignored (${Math.round(r/1e3)}s old)`);return}}if(!await e.isValidMember(s.userId))throw new Error(`User ${s.userId} is not authorized for this collaboration room`);console.log(`Verified WebRTC message from authorized room member: ${s.userId}`)}class Me extends y.lifecycle.Disposable{constructor(e,s){super(),this.matrixClient=e,this.reader=s,this._register(this.reader.onEvents(n=>n.events.forEach(i=>this.processEvent(i))))}disposed=!1;initialized=!1;initializing=!1;initializeOutdated=!1;members=new Map;powerLevels;hasWriteAccess(e,s="m.room.message"){if(!this.members.has(e))return!1;const n=this.powerLevels;let i=n.events[s];i===void 0&&(i=n.events_default);let r=n.users[e];if(r===void 0&&(r=n.users_default),typeof r!="number"||typeof i!="number")throw new Error("unexpected");return r>=i}async isValidMember(e){return this.members.has(e)}processEvent=e=>{if(!(e.type!=="m.room.power_levels"&&e.type!=="m.room.member")){if(this.initializing){this.initializeOutdated=!0;return}if(this.initialized){if(e.type==="m.room.power_levels"){this.powerLevels=e.content;return}if(e.type==="m.room.member"){if(e.content.membership==="join"||e.content.membership==="invite"){const s={displayname:e.content.displayname,user_id:e.state_key};this.members.set(e.state_key,s)}else this.members.delete(e.state_key);return}throw new Error("unexpected")}}};async initialize(){if(this.initializing||this.initialized)throw new Error("already initializing / initialized");if(!this.reader.isStarted)throw new Error("MatrixReader must have started before initializing MatrixMemberReader");this.initializing=!0;const[e,s]=await Promise.all([this.matrixClient.getStateEvent(this.reader.roomId,"m.room.power_levels",void 0),this.matrixClient.members(this.reader.roomId,void 0,["knock","leave","ban"])]);if(this.initializeOutdated)return this.initializing=!1,this.initializeOutdated=!1,this.initialize();this.powerLevels=e,s.chunk.filter(n=>n.type==="m.room.member"&&(n.content.membership==="join"||n.content.membership==="invite")).forEach(n=>{this.members.set(n.state_key,{displayname:n.content.displayname,user_id:n.state_key})}),this.initializing=!1,this.initialized=!0}dispose(){this.disposed=!0,super.dispose()}}const St=30*1e3,Ct=30*1e3,It={snapshotInterval:30};class Et extends y.lifecycle.Disposable{constructor(e,s,n,i={}){super(),this.matrixClient=e,this.roomId=s,this.translator=n,this.opts={...It,...i},this.matrixClient.on(v.RoomEvent.Timeline,this.matrixRoomListener)}latestToken;disposed=!1;polling=!1;pendingPollRequest;pollRetryTimeout;messagesSinceSnapshot=0;_onEvents=this._register(new y.event.Emitter);onEvents=this._onEvents.event;opts;matrixRoomListener=(e,s,n)=>{throw console.error("not expected; Room.timeline on MatrixClient"),new Error("unexpected, we don't use /sync calls for MatrixReader, startClient should not be used on the Matrix client")};processIncomingEventsForSnapshot(e){let s=!1;for(let n of e)if(this.translator.isUpdateEvent(n)){if(n.room_id!==this.roomId)throw new Error("event received with invalid roomid");this.messagesSinceSnapshot++,this.messagesSinceSnapshot%this.opts.snapshotInterval===0&&n.user_id===this.matrixClient.credentials.userId&&(s=!0)}else this.translator.isSnapshotEvent(n)&&(this.messagesSinceSnapshot=0,s=!1);return s}async decryptRawEventsIfNecessary(e){return await Promise.all(e.map(async n=>{if(n.type==="m.room.encrypted"){const i=new v.MatrixEvent(n);return await this.matrixClient.decryptEventIfNeeded(i),i.getEffectiveEvent()}else return n}))}async peekPoll(){if(!this.latestToken)throw new Error("polling but no pagination token");if(!this.disposed)try{this.pendingPollRequest=this.matrixClient.http.authedRequest(v.Method.Get,"/events",{room_id:this.roomId,timeout:St.toString(),from:this.latestToken});const e=await this.pendingPollRequest;if(this.pendingPollRequest=void 0,this.disposed)return;const s=await this.decryptRawEventsIfNecessary(e.chunk),n=this.processIncomingEventsForSnapshot(s);s.length&&this._onEvents.fire({events:s,shouldSendSnapshot:n}),this.latestToken=e.end,this.peekPoll()}catch(e){console.error("peek error",e),this.disposed||(this.pollRetryTimeout=setTimeout(()=>this.peekPoll(),Ct))}}async getInitialDocumentUpdateEvents(e){let s=[],n="",i=!0,r;for(;i;){const o=await this.matrixClient.createMessagesRequest(this.roomId,n,30,v.Direction.Backward),a=await this.decryptRawEventsIfNecessary(o.chunk);for(let c of a)if(e)c.type===e&&s.push(c);else if(this.translator.isSnapshotEvent(c))s.push(c),r=c.content.last_event_id;else if(this.translator.isUpdateEvent(c)){if(r&&r===c.event_id)return this.latestToken||(this.latestToken=o.start),s.reverse();this.messagesSinceSnapshot++,s.push(c)}n=o.end||"",this.latestToken||(this.latestToken=o.start),i=!!(o.start!==o.end&&o.end)}return s.reverse()}startPolling(){if(this.polling)throw new Error("already polling");this.polling=!0,this.peekPoll()}get isStarted(){return this.polling}dispose(){this.disposed=!0,super.dispose(),this.pollRetryTimeout&&clearTimeout(this.pollRetryTimeout),this.pendingPollRequest,this.matrixClient.off(v.RoomEvent.Timeline,this.matrixRoomListener)}}const Te=64,R=128,oe=63,M=127,Ut=2147483647,D=Math.floor,At=Math.abs,_t=Math.log10,xe=(t,e)=>t<e?t:e,Pe=(t,e)=>t>e?t:e,Mt=t=>t!==0?t<0:1/t<0,ke=Number.MAX_SAFE_INTEGER,Tt=Number.isInteger||(t=>typeof t=="number"&&isFinite(t)&&D(t)===t),ae=()=>new Set,xt=Array.from,Pt=Array.isArray,kt=String.fromCharCode,Rt=t=>t.toLowerCase(),Dt=/^\s*/g,Bt=t=>t.replace(Dt,""),Lt=/([A-Z])/g,Re=(t,e)=>Bt(t.replace(Lt,s=>`${e}${Rt(s)}`)),Ot=t=>{const e=unescape(encodeURIComponent(t)),s=e.length,n=new Uint8Array(s);for(let i=0;i<s;i++)n[i]=e.codePointAt(i);return n},N=typeof TextEncoder<"u"?new TextEncoder:null,ce=N?t=>N.encode(t):Ot;let W=typeof TextDecoder>"u"?null:new TextDecoder("utf-8",{fatal:!0,ignoreBOM:!0});W&&W.decode(new Uint8Array).length===1&&(W=null);const q=t=>new Error(t);class Ft{constructor(){this.cpos=0,this.cbuf=new Uint8Array(100),this.bufs=[]}}const u=()=>new Ft,Nt=t=>{let e=t.cpos;for(let s=0;s<t.bufs.length;s++)e+=t.bufs[s].length;return e},p=t=>{const e=new Uint8Array(Nt(t));let s=0;for(let n=0;n<t.bufs.length;n++){const i=t.bufs[n];e.set(i,s),s+=i.length}return e.set(new Uint8Array(t.cbuf.buffer,0,t.cpos),s),e},Wt=(t,e)=>{const s=t.cbuf.length;s-t.cpos<e&&(t.bufs.push(new Uint8Array(t.cbuf.buffer,0,t.cpos)),t.cbuf=new Uint8Array(Pe(s,e)*2),t.cpos=0)},f=(t,e)=>{const s=t.cbuf.length;t.cpos===s&&(t.bufs.push(t.cbuf),t.cbuf=new Uint8Array(s*2),t.cpos=0),t.cbuf[t.cpos++]=e},De=f,h=(t,e)=>{for(;e>M;)f(t,R|M&e),e=D(e/128);f(t,M&e)},zt=(t,e)=>{const s=Mt(e);for(s&&(e=-e),f(t,(e>oe?R:0)|(s?Te:0)|oe&e),e=D(e/64);e>0;)f(t,(e>M?R:0)|M&e),e=D(e/128)},le=new Uint8Array(3e4),jt=le.length/3,Vt=(t,e)=>{if(e.length<jt){const s=N.encodeInto(e,le).written||0;h(t,s);for(let n=0;n<s;n++)f(t,le[n])}else g(t,ce(e))},$t=(t,e)=>{const s=unescape(encodeURIComponent(e)),n=s.length;h(t,n);for(let i=0;i<n;i++)f(t,s.codePointAt(i))},B=N&&N.encodeInto?Vt:$t,Ht=(t,e)=>{const s=t.cbuf.length,n=t.cpos,i=xe(s-n,e.length),r=e.length-i;t.cbuf.set(e.subarray(0,i),n),t.cpos+=i,r>0&&(t.bufs.push(t.cbuf),t.cbuf=new Uint8Array(Pe(s*2,r)),t.cbuf.set(e.subarray(i)),t.cpos=r)},g=(t,e)=>{h(t,e.byteLength),Ht(t,e)},he=(t,e)=>{Wt(t,e);const s=new DataView(t.cbuf.buffer,t.cpos,e);return t.cpos+=e,s},qt=(t,e)=>he(t,4).setFloat32(0,e,!1),Gt=(t,e)=>he(t,8).setFloat64(0,e,!1),Jt=(t,e)=>he(t,8).setBigInt64(0,e,!1),Be=new DataView(new ArrayBuffer(4)),Yt=t=>(Be.setFloat32(0,t),Be.getFloat32(0)===t),G=(t,e)=>{switch(typeof e){case"string":f(t,119),B(t,e);break;case"number":Tt(e)&&At(e)<=Ut?(f(t,125),zt(t,e)):Yt(e)?(f(t,124),qt(t,e)):(f(t,123),Gt(t,e));break;case"bigint":f(t,122),Jt(t,e);break;case"object":if(e===null)f(t,126);else if(Pt(e)){f(t,117),h(t,e.length);for(let s=0;s<e.length;s++)G(t,e[s])}else if(e instanceof Uint8Array)f(t,116),g(t,e);else{f(t,118);const s=Object.keys(e);h(t,s.length);for(let n=0;n<s.length;n++){const i=s[n];B(t,i),G(t,e[i])}}break;case"boolean":f(t,e?120:121);break;default:f(t,127)}},Le=q("Unexpected end of array"),Oe=q("Integer out of Range");class Kt{constructor(e){this.arr=e,this.pos=0}}const T=t=>new Kt(t),Xt=(t,e)=>{const s=new Uint8Array(t.arr.buffer,t.pos+t.arr.byteOffset,e);return t.pos+=e,s},I=t=>Xt(t,w(t)),J=t=>t.arr[t.pos++],w=t=>{let e=0,s=1;const n=t.arr.length;for(;t.pos<n;){const i=t.arr[t.pos++];if(e=e+(i&M)*s,s*=128,i<R)return e;if(e>ke)throw Oe}throw Le},Qt=t=>{let e=t.arr[t.pos++],s=e&oe,n=64;const i=(e&Te)>0?-1:1;if((e&R)===0)return i*s;const r=t.arr.length;for(;t.pos<r;){if(e=t.arr[t.pos++],s=s+(e&M)*n,n*=128,e<R)return i*s;if(s>ke)throw Oe}throw Le},z=W?t=>W.decode(I(t)):t=>{let e=w(t);if(e===0)return"";{let s=String.fromCodePoint(J(t));if(--e<100)for(;e--;)s+=String.fromCodePoint(J(t));else for(;e>0;){const n=e<1e4?e:1e4,i=t.arr.subarray(t.pos,t.pos+n);t.pos+=n,s+=String.fromCodePoint.apply(null,i),e-=n}return decodeURIComponent(escape(s))}},de=(t,e)=>{const s=new DataView(t.arr.buffer,t.arr.byteOffset+t.pos,e);return t.pos+=e,s},Zt=[t=>{},t=>null,Qt,t=>de(t,4).getFloat32(0,!1),t=>de(t,8).getFloat64(0,!1),t=>de(t,8).getBigInt64(0,!1),t=>!1,t=>!0,z,t=>{const e=w(t),s={};for(let n=0;n<e;n++){const i=z(t);s[i]=Y(t)}return s},t=>{const e=w(t),s=[];for(let n=0;n<e;n++)s.push(Y(t));return s},I],Y=t=>Zt[127-J(t)](t),ue=0,Fe=1,fe=2,es=(t,e)=>{h(t,ue);const s=m.encodeStateVector(e);g(t,s)},ts=(t,e,s)=>{h(t,Fe),g(t,m.encodeStateAsUpdate(e,s))},ss=(t,e,s)=>ts(e,s,I(t)),Ne=(t,e,s)=>{try{m.applyUpdate(e,I(t),s)}catch(n){console.error("Caught error while handling a Yjs update",n)}},We=(t,e)=>{h(t,fe),g(t,e)},ns=Ne,ze=(t,e,s,n)=>{const i=w(t);switch(i){case ue:ss(t,e,s);break;case Fe:Ne(t,s,n);break;case fe:ns(t,s,n);break;default:throw new Error("Unknown message type")}return i},x=()=>new Map,j=(t,e,s)=>{let n=t.get(e);return n===void 0&&t.set(e,n=s()),n},is=(t,e)=>{const s=[];for(const[n,i]of t)s.push(e(i,n));return s},je=t=>t===void 0?null:t;class rs{constructor(){this.map=new Map}setItem(e,s){this.map.set(e,s)}getItem(e){return this.map.get(e)}}let Ve=new rs,pe=!0;try{typeof localStorage<"u"&&localStorage&&(Ve=localStorage,pe=!1)}catch{}const $e=Ve,os=t=>pe||addEventListener("storage",t),as=t=>pe||removeEventListener("storage",t),cs=Object.keys,He=t=>cs(t).length,ls=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),qe=Symbol("Equality"),hs=()=>{},V=(t,e)=>{if(t===e)return!0;if(t==null||e==null||t.constructor!==e.constructor)return!1;if(t[qe]!=null)return t[qe](e);switch(t.constructor){case ArrayBuffer:t=new Uint8Array(t),e=new Uint8Array(e);case Uint8Array:{if(t.byteLength!==e.byteLength)return!1;for(let s=0;s<t.length;s++)if(t[s]!==e[s])return!1;break}case Set:{if(t.size!==e.size)return!1;for(const s of t)if(!e.has(s))return!1;break}case Map:{if(t.size!==e.size)return!1;for(const s of t.keys())if(!e.has(s)||!V(t.get(s),e.get(s)))return!1;break}case Object:if(He(t)!==He(e))return!1;for(const s in t)if(!ls(t,s)||!V(t[s],e[s]))return!1;break;case Array:if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(!V(t[s],e[s]))return!1;break;default:return!1}return!0},ds=(t,e)=>e.includes(t),L=typeof process<"u"&&process.release&&/node|io\.js/.test(process.release.name)&&Object.prototype.toString.call(typeof process<"u"?process:0)==="[object process]",Ge=typeof window<"u"&&typeof document<"u"&&!L;let S;const us=()=>{if(S===void 0)if(L){S=x();const t=process.argv;let e=null;for(let s=0;s<t.length;s++){const n=t[s];n[0]==="-"?(e!==null&&S.set(e,""),e=n):e!==null&&(S.set(e,n),e=null)}e!==null&&S.set(e,"")}else typeof location=="object"?(S=x(),(location.search||"?").slice(1).split("&").forEach(t=>{if(t.length!==0){const[e,s]=t.split("=");S.set(`--${Re(e,"-")}`,s),S.set(`-${Re(e,"-")}`,s)}})):S=x();return S},me=t=>us().has(t),K=t=>je(L?process.env[t.toUpperCase().replaceAll("-","_")]:$e.getItem(t)),Je=t=>me("--"+t)||K(t)!==null;Je("production");const fs=L&&ds(process.env.FORCE_COLOR,["true","1","2"])||!me("--no-colors")&&!Je("no-color")&&(!L||process.stdout.isTTY)&&(!L||me("--color")||K("COLORTERM")!==null||(K("TERM")||"").includes("color"));class ps{constructor(e,s){this.left=e,this.right=s}}const E=(t,e)=>new ps(t,e);typeof DOMParser<"u"&&new DOMParser;const ms=t=>is(t,(e,s)=>`${s}:${e};`).join(""),gs=JSON.stringify,U=Date.now,A=Symbol,_=A(),X=A(),Ye=A(),ge=A(),Ke=A(),ys=A(),Xe=A(),Qe=A(),Q=A(),ws=t=>{t.length===1&&t[0]?.constructor===Function&&(t=t[0]());const e=[],s=[];let n=0;for(;n<t.length;n++){const i=t[n];if(i===void 0)break;if(i.constructor===String||i.constructor===Number)e.push(i);else if(i.constructor===Object)break}for(n>0&&s.push(e.join(""));n<t.length;n++){const i=t[n];i instanceof Symbol||s.push(i)}return s},Ze=[Ke,Xe,Qe,Ye];let ye=0,et=U();const bs=(t,e)=>{const s=Ze[ye],n=K("log"),i=n!==null&&(n==="*"||n==="true"||new RegExp(n,"gi").test(e));return ye=(ye+1)%Ze.length,e+=": ",i?(...r)=>{r.length===1&&r[0]?.constructor===Function&&(r=r[0]());const o=U(),a=o-et;et=o,t(s,e,Q,...r.map(c=>{switch(c!=null&&c.constructor===Uint8Array&&(c=Array.from(c)),typeof c){case"string":case"symbol":return c;default:return gs(c)}}),s," +"+a+"ms")}:hs},vs={[_]:E("font-weight","bold"),[X]:E("font-weight","normal"),[Ye]:E("color","blue"),[Ke]:E("color","green"),[ge]:E("color","grey"),[ys]:E("color","red"),[Xe]:E("color","purple"),[Qe]:E("color","orange"),[Q]:E("color","black")},Ss=fs?t=>{t.length===1&&t[0]?.constructor===Function&&(t=t[0]());const e=[],s=[],n=x();let i=[],r=0;for(;r<t.length;r++){const o=t[r],a=vs[o];if(a!==void 0)n.set(a.left,a.right);else{if(o===void 0)break;if(o.constructor===String||o.constructor===Number){const c=ms(n);r>0||c.length>0?(e.push("%c"+o),s.push(c)):e.push(o)}else break}}for(r>0&&(i=s,i.unshift(e.join("")));r<t.length;r++){const o=t[r];o instanceof Symbol||i.push(o)}return i}:ws,Cs=(...t)=>{console.log(...Ss(t)),Is.forEach(e=>e.print(t))},Is=ae(),O=t=>bs(Cs,t);class tt{room=null;doc;roomId;matrixClient;opts;onCustomMessage=(e,s)=>{console.warn("[MatrixWebrtcProvider] onCustomMessage not implemented")};onPeerConnected=e=>{console.warn("[MatrixWebrtcProvider] onPeerConnected not implemented")};constructor(e,s,n,i={}){this.doc=e,this.matrixClient=s,this.roomId=n,this.opts={maxConns:20+Math.floor(Math.random()*15),peerOpts:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:global.stun.twilio.com:3478"}]},...i},this.room=new Es(this,s,n,this.opts)}destroy(){this.room&&(this.room.disconnect(),this.room=null)}}class Es{constructor(e,s,n,i){this.provider=e,this.matrixClient=s,this.roomId=n,this.opts=i,this.myPeerId=`${s.getUserId()}-${Date.now()}`,console.log("[MatrixWebrtcRoom] Initializing with peerId:",this.myPeerId),this.connect()}webrtcConns=new Map;myPeerId;connect(){this.matrixClient.on("Room.timeline",this.handleMatrixEvent.bind(this)),this.announcePresence()}disconnect(){console.log("[MatrixWebrtcRoom] Disconnecting"),this.webrtcConns.forEach(e=>e.close()),this.webrtcConns.clear(),this.matrixClient.off("Room.timeline",this.handleMatrixEvent.bind(this))}async announcePresence(){await this.matrixClient.sendEvent(this.roomId,"com.yjs.webrtc.announce",{peerId:this.myPeerId,timestamp:Date.now()})}handleMatrixEvent(e,s){if(s.roomId!==this.roomId)return;const n=e.getSender(),i=e.getContent(),r=e.getType();if(!(n===this.matrixClient.getUserId()&&i.peerId===this.myPeerId))switch(r){case"com.yjs.webrtc.announce":this.webrtcConns.size<(this.opts.maxConns??20)&&this.handlePeerAnnounce(i.peerId,n);break;case"com.yjs.webrtc.signal":i.targetPeer===this.myPeerId&&this.handleWebrtcSignal(i);break}}async handlePeerAnnounce(e,s){if(this.webrtcConns.has(e))return;const n=this.matrixClient.getUserId()<s,i=new st(this,e,s,n,this.matrixClient,this.roomId,this.myPeerId,this.opts.peerOpts);this.webrtcConns.set(e,i),this.setupConnectionHandlers(i),n&&await i.initiate()}handleWebrtcSignal(e){const s=this.webrtcConns.get(e.fromPeer);if(s)s.handleSignal(e.signal);else if(e.signal.type==="offer"){const n=new st(this,e.fromPeer,e.fromUser,!1,this.matrixClient,this.roomId,this.myPeerId,this.opts.peerOpts);this.webrtcConns.set(e.fromPeer,n),this.setupConnectionHandlers(n),n.handleSignal(e.signal)}}setupConnectionHandlers(e){e.onopen=()=>{this.provider.onPeerConnected(s=>e.send(s))},e.onmessage=s=>{this.provider.onCustomMessage(s,n=>e.send(n))},e.onclose=()=>{this.webrtcConns.delete(e.peerId)}}broadcastRoomMessage(e){this.webrtcConns.forEach(s=>{s.connected&&s.send(e)})}get peers(){return this.webrtcConns}}class st{constructor(e,s,n,i,r,o,a,c){this.room=e,this.peerId=s,this.userId=n,this.isInitiator=i,this.matrixClient=r,this.roomId=o,this.myPeerId=a,this.pc=new RTCPeerConnection(c),this.setupPeerConnection()}connected=!1;onopen=null;onmessage=null;onclose=null;pc;channel=null;setupPeerConnection(){this.pc.onicecandidate=e=>{e.candidate&&this.sendSignal({type:"ice-candidate",candidate:e.candidate})},this.pc.ondatachannel=e=>{this.setupDataChannel(e.channel)}}setupDataChannel(e){this.channel=e,e.onopen=()=>{this.connected=!0,this.onopen?.()},e.onmessage=s=>this.onmessage?.(new Uint8Array(s.data)),e.onclose=()=>{this.connected=!1,this.onclose?.()}}async initiate(){this.channel=this.pc.createDataChannel("yjs",{ordered:!0}),this.setupDataChannel(this.channel);const e=await this.pc.createOffer();await this.pc.setLocalDescription(e),this.sendSignal({type:"offer",offer:e})}async handleSignal(e){switch(e.type){case"offer":{if(this.isInitiator){console.debug("[MatrixWebrtcConn] Ignoring colliding offer â€“ I am initiator");return}await this.pc.setRemoteDescription(e.offer);const s=await this.pc.createAnswer();await this.pc.setLocalDescription(s),this.sendSignal({type:"answer",answer:s});break}case"answer":{if(this.pc.signalingState!=="have-local-offer")return;await this.pc.setRemoteDescription(e.answer);break}case"ice-candidate":try{await this.pc.addIceCandidate(e.candidate)}catch{}break}}async sendSignal(e){await this.matrixClient.sendEvent(this.roomId,"com.yjs.webrtc.signal",{fromPeer:this.myPeerId,fromUser:this.matrixClient.getUserId(),targetPeer:this.peerId,signal:e})}send(e){if(this.channel&&this.connected){const s=e.buffer instanceof ArrayBuffer?e:new Uint8Array(new ArrayBuffer(e.byteLength));s!==e&&s.set(e),this.channel.send(s)}}close(){this.pc.close(),this.channel?.close(),this.connected=!1,this.onclose?.()}}function we(t){const e=t instanceof ArrayBuffer?new Uint8Array(t):t;return Buffer.from(e).toString("base64")}function nt(t){const e=Buffer.from(t,"base64");return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}const Us=O("signed-webrtc"),it=0,be=1;class rt extends tt{constructor(e,s,n,i,r,o,a){super(e,s,n,a),this.sign=i,this.verify=r,this.awareness=o,e.on("update",this._docUpdateHandler),e.on("destroy",this.destroy.bind(this)),this.awareness&&this.awareness.on("update",this._awarenessUpdateHandler),typeof window<"u"&&window.addEventListener("beforeunload",()=>{this.awareness&&this.awareness.setLocalState(null),this.destroy()})}awareness;onCustomMessage=(e,s)=>{const n=T(e),i=u();switch(w(n)){case it:const o=Y(n);this.verify(o).then(()=>{const a=nt(o.message),c=T(a);if(ze(c,i,this.doc,this)!==fe)throw Us("error: expect only updates"),new Error("error: only update messages expected")},a=>{console.error("couldn't verify message",a)});break;case be:if(this.awareness){const a=I(n);this.awareness.applyAwarenessUpdateFromBytes(a)}break}};onPeerConnected=e=>{if(console.log("WebRTC peer connected for real-time document sync"),this.awareness&&this.awareness.getLocalState()){const n=u();h(n,be),g(n,this.awareness.encodeAwarenessUpdate()),e(p(n))}};_docUpdateHandler=async(e,s)=>{if(!this.room||s===this)return;const n=u();h(n,it);const i=u();We(i,e);const r={message:we(p(i))};await this.sign(r),G(n,r),this.room.broadcastRoomMessage(p(n))};_awarenessUpdateHandler=({added:e,updated:s,removed:n},i)=>{const r=this.room;if(!r||!this.awareness){console.log("[SignedWebrtcProvider] No room or awareness available");return}e.concat(s).concat(n),console.log("[SignedWebrtcProvider] Awareness change:",{added:e,updated:s,removed:n});const o=u();h(o,be),g(o,this.awareness.encodeAwarenessUpdate());const a=p(o);console.log("[SignedWebrtcProvider] Broadcasting awareness update, size:",a.length),r.broadcastRoomMessage(a)};destroy(){this.awareness&&this.awareness.off("update",this._awarenessUpdateHandler),this.doc.off("update",this._docUpdateHandler),this.doc.off("destroy",this.destroy),super.destroy()}}class As{constructor(e){this.doc=e,this.clientId=this.generateClientId(),this.cleanupInterval=setInterval(()=>this.cleanupStaleStates(),3e4),this.debug&&console.log("[BlockNoteAwareness] Initialized with clientId:",this.clientId)}states=new Map;localState=null;clientId;listeners={};cleanupInterval;debug=!0;generateClientId(){return Date.now()+"-"+Math.random().toString(36).substr(2,9)}get clientID(){return this.clientId}setLocalState(e){this.debug&&console.log("[BlockNoteAwareness] setLocalState called:",e),e===null?(this.localState=null,this.states.delete(this.clientId)):(this.localState={...this.localState,...e,timestamp:Date.now()},this.states.set(this.clientId,this.localState));const s={added:[],updated:[this.clientId],removed:e===null?[this.clientId]:[]};this.emit("change",s),this.emit("update",s)}setLocalStateField(e,s){this.debug&&console.log("[BlockNoteAwareness] setLocalStateField:",e,s),this.localState||(this.localState={timestamp:Date.now()}),this.localState[e]=s,this.localState.timestamp=Date.now(),this.states.set(this.clientId,this.localState);const n={added:[],updated:[this.clientId],removed:[]};this.emit("change",n),this.emit("update",n)}getStates(){return new Map(this.states)}getLocalState(){return this.localState}applyAwarenessUpdate(e){const{clientId:s,state:n}=e;if(this.debug&&console.log("[BlockNoteAwareness] applyAwarenessUpdate:",e),s===this.clientId)return;const i=this.states.has(s);n===null?(this.states.delete(s),i&&this.emit("change",{added:[],updated:[],removed:[s]})):(this.states.set(s,n),this.emit("change",{added:i?[]:[s],updated:i?[s]:[],removed:[]}))}encodeAwarenessUpdate(){if(!this.localState)return new Uint8Array(0);const e={clientId:this.clientId,state:this.localState},s=JSON.stringify(e);return this.debug&&console.log("[BlockNoteAwareness] Encoding update:",e),new TextEncoder().encode(s)}applyAwarenessUpdateFromBytes(e){try{const s=new TextDecoder().decode(e),n=JSON.parse(s);this.debug&&console.log("[BlockNoteAwareness] Received update bytes:",n),this.applyAwarenessUpdate(n)}catch(s){console.error("[BlockNoteAwareness] Failed to decode awareness update:",s)}}cleanupStaleStates(){const e=Date.now(),s=30*1e3,n=[];this.states.forEach((i,r)=>{r!==this.clientId&&e-i.timestamp>s&&n.push(r)}),n.length>0&&(this.debug&&console.log("[BlockNoteAwareness] Cleaning up stale states:",n),n.forEach(i=>this.states.delete(i)),this.emit("change",{added:[],updated:[],removed:n}))}on(e,s){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(s),this.debug&&console.log("[BlockNoteAwareness] Listener added for event:",e)}off(e,s){if(this.listeners[e]){const n=this.listeners[e].indexOf(s);n>-1&&this.listeners[e].splice(n,1)}}emit(e,s){this.debug&&console.log("[BlockNoteAwareness] Emitting event:",e,s),this.listeners[e]&&this.listeners[e].forEach(n=>{try{n(s)}catch(i){console.error("[BlockNoteAwareness] Error in event listener:",i)}})}destroy(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.states.clear(),this.listeners={},this.localState=null,this.debug&&console.log("[BlockNoteAwareness] Destroyed")}}const _s={flushInterval:process.env.NODE_ENV==="test"?100:500,retryIfForbiddenInterval:1e3*30};class Ms extends y.lifecycle.Disposable{constructor(e,s,n={}){super(),this.matrixClient=e,this.translator=s,this.opts={..._s,...n},this.throttledFlushUpdatesToMatrix=vt.throttle(this.flushUpdatesToMatrix,this.canWrite?this.opts.flushInterval:this.opts.retryIfForbiddenInterval)}pendingUpdates=[];isSendingUpdates=!1;_canWrite=!0;retryTimeoutHandler;roomId;_onCanWriteChanged=this._register(new y.event.Emitter);onCanWriteChanged=this._onCanWriteChanged.event;_onSentAllEvents=this._register(new y.event.Emitter);onSentAllEvents=this._onSentAllEvents.event;throttledFlushUpdatesToMatrix;opts;setCanWrite(e){this._canWrite!==e&&(this._canWrite=e,this._onCanWriteChanged.fire())}flushUpdatesToMatrix=async()=>{if(this.isSendingUpdates||!this.pendingUpdates.length||!this.roomId)return;this.isSendingUpdates=!0;const e=m.mergeUpdates(this.pendingUpdates);this.pendingUpdates=[];let s=!1;try{console.log("Sending updates"),await this.translator.sendUpdate(this.matrixClient,this.roomId,e),this.setCanWrite(!0),console.log("sent updates")}catch(n){if(n.errcode==="M_FORBIDDEN"){console.warn("not allowed to edit document",n),this.setCanWrite(!1);try{await this.matrixClient.joinRoom(this.roomId),console.log("joined room",this.roomId),s=!0}catch(i){console.warn("failed to join room",i)}}else console.error("error sending updates",n);this.pendingUpdates.unshift(e)}finally{this.isSendingUpdates=!1}this.pendingUpdates.length?this.retryTimeoutHandler=setTimeout(()=>{this.throttledFlushUpdatesToMatrix()},s?0:this.canWrite?this.opts.flushInterval:this.opts.retryIfForbiddenInterval):(console.log("_onSentAllEvents"),this._onSentAllEvents.fire())};async initialize(e){this.roomId=e,this.throttledFlushUpdatesToMatrix()}get canWrite(){return this._canWrite}writeUpdate(e){this.pendingUpdates.push(e),this.throttledFlushUpdatesToMatrix()}async waitForFlush(){!this.pendingUpdates.length&&!this.isSendingUpdates||await y.event.Event.toPromise(this.onSentAllEvents)}dispose(){super.dispose(),clearTimeout(this.retryTimeoutHandler),this.throttledFlushUpdatesToMatrix.cancel()}}function Ts(t,e){return xs(new DataView(t),new DataView(e))}function xs(t,e){if(t.byteLength!==e.byteLength)return!1;for(let s=0;s<t.byteLength;s++)if(t.getUint8(s)!==e.getUint8(s))return!1;return!0}const $="m.room.message",Ps={updatesAsRegularMessages:!1,updateEventType:"matrix-crdt.doc_update",snapshotEventType:"matrix-crdt.doc_snapshot"};class ks{opts;constructor(e={}){this.opts={...Ps,...e}}async sendUpdate(e,s,n){const i=we(n),r={update:i};if(this.opts.updatesAsRegularMessages){const o={body:this.opts.updateEventType+": "+i,msgtype:this.opts.updateEventType,...r};"scheduler"in e&&(e.scheduler=void 0),await e.sendEvent(s,$,o,"")}else await e.sendEvent(s,this.opts.updateEventType,r,"")}async sendSnapshot(e,s,n,i){const r=we(n),o={update:r,last_event_id:i};if(this.opts.updatesAsRegularMessages){const a={body:this.opts.snapshotEventType+": "+r,msgtype:this.opts.snapshotEventType,...o};"scheduler"in e&&(e.scheduler=void 0),await e.sendEvent(s,$,a,"")}else await e.sendEvent(s,this.opts.snapshotEventType,o,"")}isUpdateEvent(e){return this.opts.updatesAsRegularMessages?e.type===$&&e.content.msgtype===this.opts.updateEventType:e.type===this.opts.updateEventType}isSnapshotEvent(e){return this.opts.updatesAsRegularMessages?e.type===$&&e.content.msgtype===this.opts.snapshotEventType:e.type===this.opts.snapshotEventType}get WrappedEventType(){return this.opts.updatesAsRegularMessages?$:this.opts.updateEventType}}const Rs={enableExperimentalWebrtcSync:!1,enableAwareness:!1,reader:{},writer:{},translator:{}};class Ds extends y.lifecycle.Disposable{constructor(e,s,n,i={}){super(),this.doc=e,this.matrixClient=s,this.room=n,this.opts={...Rs,...i},this.translator=new ks(this.opts.translator),this.throttledWriter=new Ms(this.matrixClient,this.translator,this.opts.writer),this.opts.enableAwareness&&(this.awareness=new As(e)),e.on("update",this.documentUpdateListener)}disposed=!1;_roomId;initializeTimeoutHandler;initializedResolve;initializedPromise=new Promise(e=>{this.initializedResolve=e});webrtcProvider;reader;throttledWriter;translator;awareness;_onDocumentAvailable=this._register(new y.event.Emitter);_onDocumentUnavailable=this._register(new y.event.Emitter);_onReceivedEvents=this._register(new y.event.Emitter);opts;onDocumentAvailable=this._onDocumentAvailable.event;onReceivedEvents=this._onReceivedEvents.event;onDocumentUnavailable=this._onDocumentUnavailable.event;get onCanWriteChanged(){return this.throttledWriter.onCanWriteChanged}get canWrite(){return this.throttledWriter.canWrite}get roomId(){return this._roomId}get matrixReader(){return this.reader}get awarenessInstance(){return this.awareness}totalEventsReceived=0;documentUpdateListener=async(e,s)=>{s===this||this.webrtcProvider&&s===this.webrtcProvider||s?.provider||this.throttledWriter.writeUpdate(e)};processIncomingEvents=(e,s=!1)=>{e=e.filter(o=>!(!this.translator.isUpdateEvent(o)&&!this.translator.isSnapshotEvent(o))),this.totalEventsReceived+=e.length;const n=e.map(o=>new Uint8Array(nt(o.content.update))),i=m.mergeUpdates(n);if(!n.length)return i;if(m.applyUpdate(this.doc,i,this),s){const o=e[e.length-1],a=m.encodeStateAsUpdate(this.doc);this.translator.sendSnapshot(this.matrixClient,this._roomId,a,o.event_id).catch(c=>{console.error("failed to send snapshot")})}return e.filter(o=>o.user_id!==this.matrixClient.credentials.userId).length&&this._onReceivedEvents.fire(),i};async initializeWebrtc(){if(!this._roomId)throw new Error("not initialized");if(!this.reader)throw new Error("needs reader to initialize webrtc");const e=this._register(new Me(this.matrixClient,this.reader));await e.initialize();const s=bt.createClient({baseUrl:this.matrixClient.baseUrl||this.matrixClient.clientOpts?.baseUrl,accessToken:this.matrixClient.getAccessToken?this.matrixClient.getAccessToken():this.matrixClient.credentials?.accessToken,userId:this.matrixClient.getUserId()||void 0,timelineSupport:!0});let n;try{const i={room:{timeline:{limit:10,types:["com.yjs.webrtc.*"]}},presence:{types:[]},account_data:{types:[]}};n=await s.createFilter(i)}catch{}s.startClient({filter:n,initialSyncLimit:10}),await new Promise(i=>s.once("sync",r=>r==="PREPARED"&&i())),this._register({dispose:()=>s.stopClient()}),this.webrtcProvider=new rt(this.doc,s,this._roomId,async i=>{await Ae(this.matrixClient,i)},async i=>{await _e(this.matrixClient,e,i,this.translator.WrappedEventType)},this.awareness)}async initializeNoCatch(){const e=this.room.type==="id"?this.room.id:this.room.alias;try{if(this.room.type==="id")this._roomId=this.room.id;else if(this.room.type==="alias"){const d=await this.matrixClient.getRoomIdForAlias(this.room.alias);this._roomId=d.room_id}if(!this._roomId)throw new Error("error receiving room id");console.log("room resolved",this._roomId),await this.throttledWriter.initialize(this._roomId)}catch(d){let C=5e3;d.errcode==="M_NOT_FOUND"?(console.log("room not found",e),this._onDocumentUnavailable.fire()):d.name==="ConnectionError"?console.log("room not found (offline)",e):(console.error("error retrieving room",e,d),C=30*1e3,this._onDocumentUnavailable.fire()),this.initializeTimeoutHandler=setTimeout(()=>{this.initialize()},C);return}let s=m.encodeStateAsUpdate(this.doc);const n=m.encodeStateVectorFromUpdate(s),i=m.diffUpdate(s,n);let r=m.snapshot(this.doc);const o=await this.initializeReader();this._onDocumentAvailable.fire();const a=m.encodeStateVectorFromUpdate(o),c=m.diffUpdate(s,a);if(Ts(i.buffer,c.buffer)){let d=new m.Doc;m.applyUpdate(d,o);let C=m.snapshot(d);if(Bs(C,r)){this.initializedResolve();return}}c.length>2&&this.throttledWriter.writeUpdate(c),this.initializedResolve()}async initializeReader(){if(this.reader)throw new Error("already initialized reader");if(!this._roomId)throw new Error("no roomId");this.reader=this._register(new Et(this.matrixClient,this._roomId,this.translator,this.opts.reader)),this._register(this.reader.onEvents(s=>this.processIncomingEvents(s.events,s.shouldSendSnapshot)));const e=await this.reader.getInitialDocumentUpdateEvents();return this.reader.startPolling(),this.processIncomingEvents(e)}async waitForFlush(){await this.initializedPromise,await this.throttledWriter.waitForFlush()}async initialize(){try{await this.initializeNoCatch(),await this.initializedPromise,!this.disposed&&this.opts.enableExperimentalWebrtcSync&&await this.initializeWebrtc()}catch(e){throw console.error(e),e}}dispose(){super.dispose(),this.disposed=!0,this.webrtcProvider?.destroy(),this.reader?.dispose(),this.awareness?.destroy(),clearTimeout(this.initializeTimeoutHandler),this.doc.off("update",this.documentUpdateListener)}}function Bs(t,e){for(const[s,n]of e.ds.clients.entries()){const i=t.ds.clients.get(s)||[];if(n.length>i.length)return!1;for(let r=0;r<n.length;r++){const o=n[r],a=i[r];if(o.clock!==a.clock||o.len!==a.len)return!1}}return!0}async function Ls(t,e,s){try{const n=[];return n.push({type:"m.room.guest_access",state_key:"",content:{guest_access:"forbidden"}}),n.push({type:"m.room.join_rules",content:{join_rule:s==="public-read-write"?"public":"invite"}}),n.push({type:"m.room.history_visibility",content:{history_visibility:"world_readable"}}),{status:"ok",roomId:(await t.createRoom({room_alias_name:e,visibility:"public",name:e,topic:"",initial_state:n})).room_id}}catch(n){return n.errcode==="M_ROOM_IN_USE"?"already-exists":n.name==="ConnectionError"?"offline":{status:"error",error:n}}}async function Os(t,e){let s;try{s=await t.getStateEvent(e,"m.room.join_rules")}catch(n){return{status:"error",error:n}}if(s.join_rule==="public")return"public-read-write";if(s.join_rule==="invite")return"public-read";throw new Error("unsupported join_rule")}async function Fs(t,e,s){try{return await t.sendStateEvent(e,"m.room.join_rules",{join_rule:s==="public-read-write"?"public":"invite"},""),{status:"ok",roomId:e}}catch(n){return n.name==="ConnectionError"?"offline":{status:"error",error:n}}}class ve{constructor(){this._observers=x()}on(e,s){j(this._observers,e,ae).add(s)}once(e,s){const n=(...i)=>{this.off(e,n),s(...i)};this.on(e,n)}off(e,s){const n=this._observers.get(e);n!==void 0&&(n.delete(s),n.size===0&&this._observers.delete(e))}emit(e,s){return xt((this._observers.get(e)||x()).values()).forEach(n=>n(...s))}destroy(){this._observers=x()}}const Se=3e4;class Ns extends ve{constructor(e){super(),this.doc=e,this.clientID=e.clientID,this.states=new Map,this.meta=new Map,this._checkInterval=setInterval(()=>{const s=U();this.getLocalState()!==null&&Se/2<=s-this.meta.get(this.clientID).lastUpdated&&this.setLocalState(this.getLocalState());const n=[];this.meta.forEach((i,r)=>{r!==this.clientID&&Se<=s-i.lastUpdated&&this.states.has(r)&&n.push(r)}),n.length>0&&ot(this,n,"timeout")},D(Se/10)),e.on("destroy",()=>{this.destroy()}),this.setLocalState({})}destroy(){this.emit("destroy",[this]),this.setLocalState(null),super.destroy(),clearInterval(this._checkInterval)}getLocalState(){return this.states.get(this.clientID)||null}setLocalState(e){const s=this.clientID,n=this.meta.get(s),i=n===void 0?0:n.clock+1,r=this.states.get(s);e===null?this.states.delete(s):this.states.set(s,e),this.meta.set(s,{clock:i,lastUpdated:U()});const o=[],a=[],c=[],d=[];e===null?d.push(s):r==null?e!=null&&o.push(s):(a.push(s),V(r,e)||c.push(s)),(o.length>0||c.length>0||d.length>0)&&this.emit("change",[{added:o,updated:c,removed:d},"local"]),this.emit("update",[{added:o,updated:a,removed:d},"local"])}setLocalStateField(e,s){const n=this.getLocalState();n!==null&&this.setLocalState({...n,[e]:s})}getStates(){return this.states}}const ot=(t,e,s)=>{const n=[];for(let i=0;i<e.length;i++){const r=e[i];if(t.states.has(r)){if(t.states.delete(r),r===t.clientID){const o=t.meta.get(r);t.meta.set(r,{clock:o.clock+1,lastUpdated:U()})}n.push(r)}}n.length>0&&(t.emit("change",[{added:[],updated:[],removed:n},s]),t.emit("update",[{added:[],updated:[],removed:n},s]))},at=(t,e,s=t.states)=>{const n=e.length,i=u();h(i,n);for(let r=0;r<n;r++){const o=e[r],a=s.get(o)||null,c=t.meta.get(o).clock;h(i,o),h(i,c),B(i,JSON.stringify(a))}return p(i)},Ws=(t,e,s)=>{const n=T(e),i=U(),r=[],o=[],a=[],c=[],d=w(n);for(let C=0;C<d;C++){const b=w(n);let ne=w(n);const k=JSON.parse(z(n)),ie=t.meta.get(b),Cn=t.states.get(b),mt=ie===void 0?0:ie.clock;(mt<ne||mt===ne&&k===null&&t.states.has(b))&&(k===null?b===t.clientID&&t.getLocalState()!=null?ne++:t.states.delete(b):t.states.set(b,k),t.meta.set(b,{clock:ne,lastUpdated:i}),ie===void 0&&k!==null?r.push(b):ie!==void 0&&k===null?c.push(b):k!==null&&(V(k,Cn)||a.push(b),o.push(b)))}(r.length>0||a.length>0||c.length>0)&&t.emit("change",[{added:r,updated:a,removed:c},s]),(r.length>0||o.length>0||c.length>0)&&t.emit("update",[{added:r,updated:o,removed:c},s])},Z=new Map,P=new Map;function Ce(t){Z.forEach(e=>{e.connected&&(e.send({type:"subscribe",topics:[t.name]}),t.webrtcConns.size<t.provider.maxConns&&e.publishSignalingMessage(t,{type:"announce",from:t.peerId}))})}const zs=crypto.getRandomValues.bind(crypto),js=Math.random,Vs=()=>zs(new Uint32Array(1))[0],$s="10000000-1000-4000-8000"+-1e11,Hs=()=>$s.replace(/[018]/g,t=>(t^Vs()&15>>t/4).toString(16));Promise.all.bind(Promise);const qs=t=>Promise.reject(t),Gs=(t,e)=>{const s=ce(t).buffer,n=ce(e).buffer,i=s instanceof ArrayBuffer?s:new ArrayBuffer(s.byteLength),r=n instanceof ArrayBuffer?n:new ArrayBuffer(n.byteLength);return s!==i&&new Uint8Array(i).set(new Uint8Array(s)),n!==r&&new Uint8Array(r).set(new Uint8Array(n)),crypto.subtle.importKey("raw",i,"PBKDF2",!1,["deriveKey"]).then(o=>crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:1e5,hash:"SHA-256"},o,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]))},ct=async(t,e)=>{if(!e)return t;const s=crypto.getRandomValues(new Uint8Array(12)),n=t.buffer instanceof ArrayBuffer?t:new Uint8Array(new ArrayBuffer(t.byteLength));return n!==t&&n.set(t),crypto.subtle.encrypt({name:"AES-GCM",iv:s},e,n).then(i=>{const r=u();return B(r,"AES-GCM"),g(r,s),g(r,new Uint8Array(i)),p(r)})},Js=(t,e)=>{const s=u();return G(s,t),ct(p(s),e)},lt=async(t,e)=>{if(!e)return t;const s=T(t);z(s)!=="AES-GCM"&&qs(q("Unknown encryption algorithm"));const i=I(s),r=I(s),o=i.buffer instanceof ArrayBuffer?i:new Uint8Array(new ArrayBuffer(i.byteLength)),a=r.buffer instanceof ArrayBuffer?r:new Uint8Array(new ArrayBuffer(r.byteLength));return o!==i&&o.set(i),a!==r&&a.set(r),crypto.subtle.decrypt({name:"AES-GCM",iv:o},e,a).then(c=>new Uint8Array(c))},Ys=(t,e)=>lt(t,e).then(s=>Y(T(new Uint8Array(s)))),Ks=t=>new Uint8Array(t),Xs=(t,e,s)=>new Uint8Array(t,e,s),Qs=t=>new Uint8Array(t),Zs=t=>{let e="";for(let s=0;s<t.byteLength;s++)e+=kt(t[s]);return btoa(e)},en=t=>Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("base64"),tn=t=>{const e=atob(t),s=Ks(e.length);for(let n=0;n<e.length;n++)s[n]=e.charCodeAt(n);return s},sn=t=>{const e=Buffer.from(t,"base64");return Xs(e.buffer,e.byteOffset,e.byteLength)},ht=Ge?Zs:en,dt=Ge?tn:sn,ut=new Map;class nn{constructor(e){this.room=e,this.onmessage=null,this._onChange=s=>s.key===e&&this.onmessage!==null&&this.onmessage({data:dt(s.newValue||"")}),os(this._onChange)}postMessage(e){$e.setItem(this.room,ht(Qs(e)))}close(){as(this._onChange)}}const rn=typeof BroadcastChannel>"u"?nn:BroadcastChannel,Ie=t=>j(ut,t,()=>{const e=ae(),s=new rn(t);return s.onmessage=n=>e.forEach(i=>i(n.data,"broadcastchannel")),{bc:s,subs:e}}),on=(t,e)=>(Ie(t).subs.add(e),e),an=(t,e)=>{const s=Ie(t),n=s.subs.delete(e);return n&&s.subs.size===0&&(s.bc.close(),ut.delete(t)),n},cn=(t,e,s=null)=>{const n=Ie(t);n.bc.postMessage(e),n.subs.forEach(i=>i(e,s))},ln=()=>{let t=!0;return(e,s)=>{if(t){t=!1;try{e()}finally{t=!0}}else s!==void 0&&s()}},Ee=4,ee=5,hn=O("y-webrtc");class dn{constructor(e,s,n,i,r){this.provider=e,this.onCustomMessage=s,this.onPeerConnected=n,this.name=i,this.key=r}peerId=Hs();synced=!1;webrtcConns=new Map;bcConns=new Set;mux=ln();bcconnected=!1;_bcSubscriber=e=>lt(new Uint8Array(e),this.key).then(s=>this.mux(()=>{this.readMessage(s,n=>{this.broadcastBcMessage(p(n))})}));readMessage=(e,s)=>{const n=T(e),i=u(),r=w(n),o=a=>{h(i,ee),g(i,a),s(i)};switch(r){case ee:this.onCustomMessage(I(n),o);break;case Ee:{const a=J(n)===1,c=z(n);if(c!==this.peerId&&(this.bcConns.has(c)&&!a||!this.bcConns.has(c)&&a)){const d=[],C=[];a?(this.bcConns.add(c),C.push(c),this.onPeerConnected(o)):(this.bcConns.delete(c),d.push(c)),this.provider.emit("peers",[{added:C,removed:d,webrtcPeers:Array.from(this.webrtcConns.keys()),bcPeers:Array.from(this.bcConns)}]),this.broadcastBcPeerId()}break}default:console.error("Unable to compute message");return}};broadcastBcPeerId(){if(this.provider.filterBcConns){const e=u();h(e,Ee),De(e,1),B(e,this.peerId),this.broadcastBcMessage(p(e))}}broadcastWebrtcConn(e){hn("broadcast message in ",_,this.name,X),this.webrtcConns.forEach(s=>{try{s.peer.send(e)}catch{}})}broadcastRoomMessage(e){const s=u();h(s,ee),g(s,e);const n=p(s);this.bcconnected&&this.broadcastBcMessage(n),this.broadcastWebrtcConn(n)}broadcastBcMessage(e){return ct(e,this.key).then(s=>this.mux(()=>cn(this.name,s)))}connect(){Ce(this);const e=this.name;on(e,this._bcSubscriber),this.bcconnected=!0,this.broadcastBcPeerId()}disconnect(){Z.forEach(s=>{s.connected&&s.send({type:"unsubscribe",topics:[this.name]})});const e=u();h(e,Ee),De(e,0),B(e,this.peerId),this.broadcastBcMessage(p(e)),an(this.name,this._bcSubscriber),this.bcconnected=!1,this.webrtcConns.forEach(s=>s.destroy())}destroy(){this.disconnect()}}const un=1200,fn=2500,te=3e4,Ue=t=>{if(t.shouldConnect&&t.ws===null){const e=new WebSocket(t.url),s=t.binaryType;let n=null;s&&(e.binaryType=s),t.ws=e,t.connecting=!0,t.connected=!1,e.onmessage=o=>{t.lastMessageReceived=U();const a=o.data,c=typeof a=="string"?JSON.parse(a):a;c&&c.type==="pong"&&(clearTimeout(n),n=setTimeout(r,te/2)),t.emit("message",[c,t])};const i=o=>{t.ws!==null&&(t.ws=null,t.connecting=!1,t.connected?(t.connected=!1,t.emit("disconnect",[{type:"disconnect",error:o},t])):t.unsuccessfulReconnects++,setTimeout(Ue,xe(_t(t.unsuccessfulReconnects+1)*un,fn),t)),clearTimeout(n)},r=()=>{t.ws===e&&t.send({type:"ping"})};e.onclose=()=>i(null),e.onerror=o=>i(o),e.onopen=()=>{t.lastMessageReceived=U(),t.connecting=!1,t.connected=!0,t.unsuccessfulReconnects=0,t.emit("connect",[{type:"connect"},t]),n=setTimeout(r,te/2)}}};class pn extends ve{constructor(e,{binaryType:s}={}){super(),this.url=e,this.ws=null,this.binaryType=s||null,this.connected=!1,this.connecting=!1,this.unsuccessfulReconnects=0,this.lastMessageReceived=0,this.shouldConnect=!0,this._checkInterval=setInterval(()=>{this.connected&&te<U()-this.lastMessageReceived&&this.ws.close()},te/2),Ue(this)}send(e){this.ws&&this.ws.send(JSON.stringify(e))}destroy(){clearInterval(this._checkInterval),this.disconnect(),super.destroy()}disconnect(){this.shouldConnect=!1,this.ws!==null&&this.ws.close()}connect(){this.shouldConnect=!0,!this.connected&&this.ws===null&&Ue(this)}}const F=O("y-webrtc");class ft{constructor(e,s,n,i){this.remotePeerId=n,this.room=i,F("establishing connection to ",_,n),this.peer=new wt({initiator:s,...i.provider.peerOpts}),this.peer.on("signal",r=>{e.publishSignalingMessage(i,{to:n,from:i.peerId,type:"signal",signal:r})}),this.peer.on("connect",()=>{F("connected to ",_,n),this.connected=!0,i.onPeerConnected(r=>{const o=u();h(o,ee),g(o,r),this.sendWebrtcConn(o)})}),this.peer.on("close",()=>{this.connected=!1,this.closed=!0,i.webrtcConns.has(this.remotePeerId)&&(i.webrtcConns.delete(this.remotePeerId),i.provider.emit("peers",[{removed:[this.remotePeerId],added:[],webrtcPeers:Array.from(i.webrtcConns.keys()),bcPeers:Array.from(i.bcConns)}])),this.peer.destroy(),F("closed connection to ",_,n),Ce(i)}),this.peer.on("error",r=>{F("Error in connection to ",_,n,": ",r),Ce(i)}),this.peer.on("data",r=>{F("received message from ",_,this.remotePeerId,ge," (",i.name,")",X,Q),this.room.readMessage(r,o=>{this.sendWebrtcConn(o)})})}closed=!1;connected=!1;synced=!1;sendWebrtcConn(e){F("send message to ",_,this.remotePeerId,X,ge," (",this.room.name,")",Q);try{this.peer.send(p(e))}catch{}}peer;destroy(){this.peer.destroy()}}const pt=O("y-webrtc");class mn extends pn{providers=new Set;constructor(e){super(e),this.on("connect",()=>{pt(`connected (${e})`);const s=Array.from(P.keys());this.send({type:"subscribe",topics:s}),P.forEach(n=>this.publishSignalingMessage(n,{type:"announce",from:n.peerId}))}),this.on("message",s=>{switch(s.type){case"publish":{const n=s.topic,i=P.get(n);if(i==null||typeof n!="string")return;const r=o=>{const a=i.webrtcConns,c=i.peerId;if(o==null||o.from===c||o.to!==void 0&&o.to!==c||i.bcConns.has(o.from))return;const d=a.has(o.from)?()=>{}:()=>i.provider.emit("peers",[{removed:[],added:[o.from],webrtcPeers:Array.from(i.webrtcConns.keys()),bcPeers:Array.from(i.bcConns)}]);switch(o.type){case"announce":a.size<i.provider.maxConns&&(j(a,o.from,()=>new ft(this,!0,o.from,i)),d());break;case"signal":o.to===c&&(j(a,o.from,()=>new ft(this,!1,o.from,i)).peer.signal(o.signal),d());break}};i.key?typeof s.data=="string"&&Ys(dt(s.data),i.key).then(r):r(s.data)}}}),this.on("disconnect",()=>pt(`disconnect (${e})`))}publishSignalingMessage=(e,s)=>{e.key?Js(s,e.key).then(n=>{this.send({type:"publish",topic:e.name,data:ht(n)})}):this.send({type:"publish",topic:e.name,data:s})}}O("y-webrtc");const gn=(t,e,s,n,i)=>{if(P.has(n))throw q(`A Yjs Doc connected to room "${n}" already exists!`);const r=new dn(t,e,s,n,i);return P.set(n,r),r};class yn extends ve{constructor(e,{signaling:s=["wss://signaling.yjs.dev","wss://y-webrtc-signaling-eu.herokuapp.com","wss://y-webrtc-signaling-us.herokuapp.com"],password:n=void 0,maxConns:i=20+D(js()*15),filterBcConns:r=!0,peerOpts:o={}}={}){super(),this.roomName=e,this.filterBcConns=r,this.shouldConnect=!1,this.signalingUrls=s,this.signalingConns=[],this.maxConns=i,this.peerOpts={iceServers:[]},this.key=n?Gs(n,e):Promise.resolve(void 0),this.key.then(a=>{this.room=gn(this,this.onCustomMessage,this.onPeerConnected,e,a),this.shouldConnect?this.room.connect():this.room.disconnect()}),this.connect()}shouldConnect=!1;filterBcConns=!0;signalingUrls;signalingConns;peerOpts;maxConns;key;room;get connected(){return this.room!==null&&this.shouldConnect}connect(){this.shouldConnect=!0,this.signalingUrls.forEach(e=>{const s=j(Z,e,()=>new mn(e));this.signalingConns.push(s),s.providers.add(this)}),this.room&&this.room.connect()}disconnect(){this.shouldConnect=!1,this.signalingConns.forEach(e=>{e.providers.delete(this),e.providers.size===0&&(e.destroy(),Z.delete(e.url))}),this.room&&this.room.disconnect()}destroy(){this.key.then(()=>{this.room?.destroy(),P.delete(this.roomName)}),super.destroy()}}const wn=O("y-webrtc"),H=0,bn=3,se=1;class vn extends yn{constructor(e,s,n,i=new Ns(s)){super(e,n),this.doc=s,this.awareness=i,s.on("destroy",this.destroy.bind(this)),this.doc.on("update",this._docUpdateHandler),this.awareness.on("update",this._awarenessUpdateHandler),window.addEventListener("beforeunload",()=>{ot(this.awareness,[s.clientID],"window unload"),P.forEach(r=>{r.disconnect()})})}onCustomMessage=(e,s)=>{const n=T(e),i=u();switch(w(n)){case H:{h(i,H),ze(n,i,this.doc,this)===ue&&s(p(i));break}case se:Ws(this.awareness,I(n),this);break}};onPeerConnected=e=>{const s=u();h(s,H),es(s,this.doc),e(p(s));const n=u(),i=this.awareness.getStates();i.size>0&&(h(n,se),g(n,at(this.awareness,Array.from(i.keys()))),e(p(n)))};_docUpdateHandler=(e,s)=>{if(!this.room)return;const n=u();h(n,H),We(n,e),this.room.broadcastRoomMessage(p(n))};_awarenessUpdateHandler=({added:e,updated:s,removed:n},i)=>{if(!this.room)return;const r=e.concat(s).concat(n);wn("awareness change ",{added:e,updated:s,removed:n},"local",this.awareness.clientID);const o=u();h(o,se),g(o,at(this.awareness,r)),this.room.broadcastRoomMessage(p(o))};destroy(){this.doc.off("update",this._docUpdateHandler),this.awareness.off("update",this._awarenessUpdateHandler),this.doc.off("destroy",this.destroy),super.destroy()}}class Sn{constructor(e){this.doc=e,this.clientId=this.generateClientId(),this.cleanupInterval=setInterval(()=>this.cleanupStaleStates(),3e4)}states=new Map;localState=null;clientId;listeners={};cleanupInterval;generateClientId(){return Date.now()+"-"+Math.random().toString(36).substr(2,9)}get clientID(){return this.clientId}setLocalState(e){e===null?(this.localState=null,this.states.delete(this.clientId)):(this.localState={...this.localState,...e,timestamp:Date.now()},this.states.set(this.clientId,this.localState)),this.emit("change",{added:[],updated:[this.clientId],removed:e===null?[this.clientId]:[]}),this.emit("update",{added:[],updated:[this.clientId],removed:e===null?[this.clientId]:[]})}setLocalStateField(e,s){this.localState||(this.localState={timestamp:Date.now()}),this.localState[e]=s,this.localState.timestamp=Date.now(),this.states.set(this.clientId,this.localState),this.emit("change",{added:[],updated:[this.clientId],removed:[]}),this.emit("update",{added:[],updated:[this.clientId],removed:[]})}getStates(){return new Map(this.states)}getLocalState(){return this.localState}applyAwarenessUpdate(e){const{clientId:s,state:n}=e;if(s===this.clientId)return;const i=this.states.has(s);n===null?(this.states.delete(s),i&&this.emit("change",{added:[],updated:[],removed:[s]})):(this.states.set(s,n),this.emit("change",{added:i?[]:[s],updated:i?[s]:[],removed:[]}))}encodeAwarenessUpdate(){if(!this.localState)return new Uint8Array(0);const e={clientId:this.clientId,state:this.localState},s=JSON.stringify(e);return new TextEncoder().encode(s)}applyAwarenessUpdateFromBytes(e){try{const s=new TextDecoder().decode(e),n=JSON.parse(s);this.applyAwarenessUpdate(n)}catch(s){console.error("Failed to decode awareness update:",s)}}cleanupStaleStates(){const e=Date.now(),s=30*1e3,n=[];this.states.forEach((i,r)=>{r!==this.clientId&&e-i.timestamp>s&&n.push(r)}),n.length>0&&(n.forEach(i=>this.states.delete(i)),this.emit("change",{added:[],updated:[],removed:n}))}on(e,s){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(s)}off(e,s){if(this.listeners[e]){const n=this.listeners[e].indexOf(s);n>-1&&this.listeners[e].splice(n,1)}}emit(e,s){this.listeners[e]&&this.listeners[e].forEach(n=>n(s))}destroy(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.states.clear(),this.listeners={},this.localState=null}}l.DocWebrtcProvider=vn,l.MatrixMemberReader=Me,l.MatrixProvider=Ds,l.MatrixWebrtcProvider=tt,l.SignedWebrtcProvider=rt,l.SimpleAwareness=Sn,l.createMatrixRoom=Ls,l.getMatrixRoomAccess=Os,l.messageAwareness=se,l.messageQueryAwareness=bn,l.messageSync=H,l.signObject=Ae,l.updateMatrixRoomAccess=Fs,l.verifyObject=_e,Object.defineProperty(l,Symbol.toStringTag,{value:"Module"})}));
